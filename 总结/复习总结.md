## 复习总结
### 一、html

#### 1. 你是如何理解 HTML 语义化的？（解题思路：1. 举例法， 2. 阐述法）

+ **方法1**：HTML语义化就是使用正确的标签，段落就p标签，标题就用h1~h6标签，头部就用header标签，文章就用article标签，画布就用caverns标签等等

+ **方法二**：可以从历史角度出发，首先以前的后台开发人员使用table布局，速度虽然快但是维护比较麻烦，然后到了美工人员使用div+css布局，到了后面出现专门的前端使用正确的标签进行页面开发

#### 2. meta viewport 是做什么用的，怎么写？

`<meta name="viewport" content="width=divce-width, inital-scale=1, minimun-scale=1">`

逐个单词解释意思：

Width: 控制布局视窗的宽度 divce-width为设备屏幕分辨率的宽度

Initial-scale: 指定页面的初始缩放比率，initial- scale=1表示布局视图的宽度设置为屏幕分辨率的宽度，1.5为设置为屏幕分辨率的1.5倍

Minimun-scale：指定用户能够缩放比例，值为0.5是指能够将页面缩小到出事页面的0.5倍

Maxmun-scale: 指定用户能方法的最大比例

#### 3. 你用过哪些 HTML 5 标签？

header、main、footer、section、arctic、aside、canvas、video、audio

#### 4. H5 是什么？

是一种技术集合，在移动端上面显示的动态酷炫的页面，集合了所有前端技术技巧集合

### 二、css

#### 1. 两种盒模型分别说一下

标准模型：box- sizing: content-box  这种模型设置宽度为content宽度，若设置padding、margin、border会使世纪高度增加但不会影响content的宽度

IE模型：box-sizing: border-box 元素设定的宽度和高度决定了元素的边框盒，所有的内外边距和边框都是在已设置的宽度高度内进行绘制

平时更喜欢用border- box，因为更好用

#### 2. 如何垂直居中？

1. Table自带功能
2. 父元素使用display：table ，子父元素使用display：tablde-cell
3. 绝对定位 +  margin-top: -50%
4. 绝对定位 +  translate -50%
5. flex

#### 3. 布局方案（左右宽度各300px，中间自适应）

1. float
2. 定位
3. 表格布局（table、table-cell）
4. flex布局
5. grid布局

#### 3. flex 怎么用，常用属性有哪些？

```css
diplay: flex;
align-items: center;
just-content: space-betweet\

#### 4. BFC 是什么？（解题思路：背中文意思以及出发条件即可）

BFC：块级格式化上下文

触发条件：

1. position的值不为static
2. display：table/table-cell
3. overflow： hidden
4. float：left / right
5. display：flex / inline- flex

#### 5. CSS 选择器优先级

a. 越具体优先级越高

b. 同样优先级写在后面的覆盖前面的

c. !important 优先级最高，但是要少用

#### 6. 清除浮动说一下

​```css
.clearfix: after{
		content: '';
  	display: block; // 或者table
    clear: both
}
.clearfix{
  zoom: 1; // 兼容ie
}
```

### 三、原生js

#### 1. Es6语法知道那些？怎么用的？

+ **let**：块级变量声明，只在let命令所在的代码块（块级作用域）有效------暂时性死区（只要变量在let声明前使用，就会报错）
+ **const**：块级常量声明
+ **箭头函数**： sum = (a, b) => a + b; nums.forEach(item => console.log(item)) 
+ **解构赋值**：数组解构、对象解构
+ **扩展运算符**： {...xxx} 用于取出对象中的所有可遍历苏醒，拷贝到当前对象中；
+ **import(导入)**、**export(导出)**、**export defalut(默认导出)**；
+ **Object.assign()** 对象合并，将源对象的所有可枚举属性，复制到目标对象
+ **Symbol**：基本数据类型
+ **Set去重**
+ **promise对象**： 异步对象（可以从它那里获取异步操作的消息）三种状态：pedding(进行中)、fulfilled(已成功)、rejected(已失败)
+ **proxy**： 代理器
+ **async\await**：以简洁的方式编写基于promise的异步行为，避免链式调用promise
  特性列表整理（https://fangyinghang.com/es-6-tutorials/）

#### 2. Promise、Promise.all、Promise.race分别怎么用？

+ **promise的用法**（死记）

  ```js
  function fn() {
      return new Promise(resolve, reject) {
     		// 成功时执行resolve()
          // 失败时执行reject()
      }
  }
  ```

+ **promise.all**的用法（死记）

  ```js
  promise.all([promise1, promise2]).then(success, fail);
  // promise1与promise2都成功后才会执行success
  ```

+ **promise.race**的用法（死记）

  ```js
  promise.race([promise1, promise2]).then(success, fail);
  // promise1与promise2只要有一个成功就会调用成功
  // promise1与promise2只要有一个失败就会调用失败
  // 总之，谁第一个先成功或者失败，就认为是race的状态是成功或者失败
  ```

#### 3. 手写防抖函数与节流函数

> 防抖：一段时间内等待，所有的一起执行（例如：外卖员等待拿外卖）

```js
function debound(fn, time) {
    let timeId = null;
    return function() {
    	let const = this;
        if(timeId) windown.clearTimeout(timeId)
        timeId = setTimeout(() => {
            fn.apply(const, arguments)
            timeId = null
        }, time)
    }
}
```

> 节流：相同时间内执行一次后，第二次不会执行

```js
function throttly(fn, time) {
    let canUse = true;
    return function() {
        if(canUse) {
        	fn.apply(this, arguments);
            canUse = false;
            setTimeout(() => {
                canUse = true
            }, time)
        }
    }
}
```

#### 4. **手写AJAX**(背代码)

1. 完整版

```js
// 判断兼容性
       var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject();
       request.open('GET', '/a/b?name=1254', true);
       request.onreadystatechange = function() {
           if(request.readstate === 4 && request.status === 200) {
               console.log(requset.responseText)
           }
       }
       request.send()
```

2. 简易版

   ```js
   // 判断兼容性
   var request = window.XMLHttpRequest ? new XMHttpRequest() : new ActiveXObject();
   request.open('GET', '/a/b?name=5656', true);
   request.load = function() {
       console.log(request.responseText)
   }
   request.send()
   ```

#### 5. 以下代码this指向是什么？

 1. 背代码

    **fn()**

    ​     this  =>  **Windows/global**
    
    **obj.fn()**
    
    ​     this  =>  **obj**
    **fn.call(xx)**

    ​      this  =>  **xxx 传入对象**
    **fn.apply(xx)**
    
    ​      this  =>  **xx 传入对象**
    **fn.bind(xx)**
    
    ​      this  => **xx 传入对象**
    **new Fn()** 
    
    ​      this指向**实例对象**
    **fn = () =>{}**
    
    ​      this指向外面的this
    
    > 看调用 [《this 的值到底是什么？一次说清楚》](https://zhuanlan.zhihu.com/p/23804247)

#### 6. 闭包和立即执行函数分别指的是什么？

1. **闭包**: 

    > 回答模式： 1. 什么是[闭包];  2. 【闭包】的作用是什么？

    **闭包是什么**：【函数】和【函数内部能访问到的变量】（环境）的总和，就是一个闭包
    **闭包的作用**：【间接访问一个变量】

2. **立即执行函数**

    > 回答模式： 1. 什么是立即执行函数； 2. 立即执行函数有什么用途

    **立即执行函数**就是【声明一个匿名函数，然后立马调用这个匿名函数】
    eg: `(function() {alert('我是一个匿名函数')})()`

    **立即执行函数的作用**：【创造一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」）】

#### 7. 什么是JSONP? 什么是CORS? 什么是跨域？

> 同源策略：从一个源的文档或者脚本如何与另外一个源的资源进行交互，这是一个隔离潜在恶意文件的关键安全机制（**源：协议、域名、端口，这三者有一个不同，则源不同**）

* JSONP:
    + JSONP是通过script标签加载数据的方式去获取数据当做js代码来执行
    + 提前在页面中声明一个函数，函数名通过接口传参的方式传给后台，后台解析到这个函数名后在原始数据上「包裹」这个函数名，发送给前端。简而言之，JSONP需要跟对应接口的后端配合才能实现。----只能发起get请求
* CORS：在必须跨域访问资源的情况下，浏览器和服务器怎么沟通（一般协议）
     + 跨源资源共享，它允许浏览器向跨源服务器，发送XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。（需要客户端与服务端共同配合设置）----支持所有类型http请求
     + 简单请求: (1. 请求方法是HEAD、GET、POST三种方法的任意一种； 2. HTTP的头信息不能超过：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：application/x-www.from-urlencoded、multipart/form-data、text/plain )
     + 复杂请求：(1. 请求方法是：PUT、DELETE; 2. Content-Type: application/json)
* 跨域：在浏览器同源策略的情况下，向不同的源发送XHR请求，浏览器认为该请求不受信任，禁止请求

#### 8. aysnc/await怎么用，如何捕获异常？

**aysnc/await**

`aysnc`表示函数里有异步操作，返回一个平promise对象，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句

`await`命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值

```js
// async
// 函数声明
async function foo(){}
// 函数表达式
const foo = async function() {}
// 对象的方法
let obj = { async foo() {} };
obj.foo().then(....);
// class方法
class Storage() {
    constructor() {
        super();
        this.cachePromise = caches.open('avators')
    }
    async getArray(name) {
        const cache = await this.cachePromise;
        return cache.match(`/avatars/${name}.jpg`);
    }
}
const storage = new Storage();
storage.getArray('kate').then(...)
// 箭头函数
const foo = async () =>{}
```

捕获异常：async函数内部抛出错误，会导致返回的promise对象变成reject状态。抛出的错误对象会被catch方法回调接收。除了使用.catch来错误异常，还可以使用try/catch来捕获异常

```js
async handleSubmit() {
    await Promise.all([promise1, promise2]).then(r=>{
        console.log(r)
    }).catch(err => {
        console.log(err)
    })
}
async handleSubmi() {
    try{
        await Promise.all([promise1, promise2]);
        return true
    } catch(err) {
        console.log(err)
        return false
    }
}
```

#### 9. 如何实现深拷贝？

> 深拷贝：将一个对象从内存总完整的拷贝出来，从堆内存中开辟一个区域来存放新对象，且修改新对象不会影响原对象

> 背代码，要点：
>
> 1. 递归
> 2. 判断类型
> 3. 检查环（循环引用）
> 4. 需要忽略原型

**1.  基础版本（不包括数组和嵌套）**

```js
function clone(target) {
    let cloneTarget = {};
    for(const key in target) {
        cloneTarget[key] = target[key]
    }
    return cloneTarget
}
```

**2. 升级版本**

> weakMap对象是一组键/值对的集合，其中的键是弱引用。期键必须是对象，而值可以是任意的
>
> **weakMap的作用：**如果要拷贝的对象非常庞大时，使用Map会对内存造成非常大的额外消耗，而且我们需要手动清除Map的属性才能释放这块内存，而weakMap可以帮我们化解这个问题
>
> **强引用**：

```js
function forEachKey(arr, iteratee){
    let index = -1;
    const length = arr.length;
    while(++index < length) {
        iteratee(array[index], index)
    }
    return array
}
function clone(target, map = new weakMap()) {
	// 判断类型
    if(typeof target === 'object') {
        const isArray = Array.isArray(target);
        let cloneTarget = isArray ? [] : {};
        // 防止循环引用
        if(map.get(target)){
            return map.get(target)
        }
        map.set(target, cloneTarget);
        // 克隆对象和数组
        const keys = isArray ? undefined : Object.keys(target);
        forEachKey(keys || target, (value, key) => {
            if(keys) {
                key =value
            }
            cloneTarget[key] = clone(target[key], map)
        })
        return cloneTarget
    } else {
    	return target
    }
}
```

#### 10. 如何正则实现trim()? 去除空格(背代码)

```
String.prototype.trim = function() {
	return this.replace(/^\s+$/g, '')
}
// 方式2
function trim(string) {
	return string.replace(/^\s+$/g, '')
}
```

#### 11. 不使用class如何实现继承？用class又如何实现？（背代码）

```js
// 使用call和原型链
function Person(name, year) {
    this.name = name;
    this.year = year;
}
function Child(color) {
    Person.call(this)
    this.color = color
}
Child.prototype = Object.create(Person.prototype)
Child.prototype.constructor = Child

```

```
// 使用class实现继承
class Person {
	constructor(color) {
		this.color = color
	}
}
class Child extends Person{
	constructor(coloe, name) {
		super(color)
		this.name = name
	}
}
```

#### 12. 数组去重

> 1. 计数排序变形，背代码
> 2. 使用 Set（面试已经禁止这种了，因为太简单）
> 3. 使用 WeakMap

#### 13. 手写一个 Promise

参考 https://juejin.im/post/5aafe3edf265da238f125c0a

### 二、DOM相关

#### 1. DOM事件类：DOM事件级别

> 1. DOM1.0 ：element.onclick = function() {}
> 2. DOM2.0：element.addEventLister('click', function() {}, false)
> 3. DOM3.0：element.addEventLister('keyup', function() {}, false) // 新增键盘事件

#### 2. DOM事件模型：冒泡与捕获

> 捕获：从上而下： 开始为window
>
> 捕获：从目标元素开始往上面找

**DOM事件流**：事件（捕获）目标阶段    =>   目标事件    =>    冒泡 => 给事件对象



#### 1. 事件委托: 事件代理，将原本绑定在子元素身上的事件委托给父元素，让父元素去监听事件。原理就是利用事件冒泡

```

```

### HTTP

#### 1. HTTP状态码有哪些？分别的意义是什么？

+ 2xx: 表示成功
+ 3xx: 表示需要进一步操作：例如：301 永久重定向， 302 暂时重定向
+ 4xx: 表示客户端（浏览器）方面出问题  例如：400 入参错误
+ 5xx: 表示服务端出问题 ， 例如： 500 服务器出问题   503  服务器环境在构建 

> 参考资料：https://imweb.io/topic/5795dcb6fb312541492eda8c

#### 2. HTTP缓存有哪几种？

ETag、CacheControl、Expires 异同

+ **ETag**是通过对比浏览器和服务器自愿的特征值（如MD5）来决定是否要发送文件内容，如果一样就只能发送304（not modified）

+ **Expires**是通过设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题

+ **cacheControl: max-age=3600** 设置过期时长（相对时间），跟本地时间无关

### 3. Get和POST的区别

+ 语义，get是获取资源的，post是提交资源
+ get请求在url中传送的参数是有长度限制的，而post 没有
+ get请求通过url传递，post则放在requst body中
+ get请求会被浏览器主动缓存，而post 不会，除非手动缓存

#### 4. cookie / localstorage  /  sessionStorage   /  session

1. cookie / localstorage
   + 主要区别在于cookie会被发送到服务器，而localstorage不会
   + cookie的大小一般在4k，localstorage可以有5MB或者10mb（浏览器各不相同）

2. localstorage、sessionstorage
   + localstorage不会自动过期（除非用户手动清除），而sessionstorage在会话结束时过期（浏览器关闭）

3. cookie、session
   + cookie 存在浏览器的文件里，session存在服务器的文件里
   + session是基于cookie实现的，具体做法就是吧sessionID存在cookie中



### webpack

#### 1. webpack的构建流程是什么？从读取配置到输出这个文件尽量说全

+ 初始化参数：从配置文件和shell 语句中读取与合并参数，得出最终的参数；
+ 开始编译：用上一步得到的参数初始化compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译；
+ 确定入口：根据配置中的entry找出所有的入口文件；
+ 编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，再找出该模块依赖的模块，再递归本步骤直至所有入口依赖的文件都经过了本步骤的处理；
+ 完成模块编译：在经过上个步骤使用loader编译完所有模块后，得到了每个模块被编译后的最终内容以及他们之前的依赖关系；
+ 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换为一个单独的文件加入到输出列表，这个步骤是可以修改输出内容的最后机会；
+ 输出完成，在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

以上过程中，webpack会在特定的时间点广播出特定的事件，插件再监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果

#### 2. Loader和Plugin的不同？

**作用不同**

+ **loader**: 加载器，webpack把一切文件视为模块，但是webpack原生只能解析js文件，如果想将其他温江也打包的话，就会用到loader，所有loader 的作用是让webpack拥有加载和解析非JavaScript 文件的能力
+ **plugin**：插件，可以拓展webpack的功能，让webpack具有更多灵活性，在webpack的运行生命周期中会广播很多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果

**用法不同**

+ **loader**在`module.rules`中配置，他是作为模块的解析规则存在的。类型为数组，每一个项都是一个object，里面描述了对于什么类型的文件（test）,使用什么loader 和使用的参数（options）
+ **plugin**在`puligin`中单独配置，类型为数组，每一项是一个plugin 的实例，参数通过构造函数传入

#### 3. webpack的热更新是如何做到的？说明其原理

webpack的热更新又称为热替换（Hot Module Replacement）,缩写HRM。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。





























### typescript

	1.never类型是什么？ 不应该出现的类型


​	
​	

说明文档

1、描述：本项目高效便捷地实现社区的人、财、物的管理，涵盖社区服务、社商经营、平台运营和企业管理四大模块。流程化管理与个性化运营相结合，可建立物业服务标准、流程标准、管家服务体系等标准化管理流程，也可针对各社区做个性化配置。实时掌握社区用户及社区服务人员动态，快速响应用户的服务请求，智能调度社区服务人员，为社区用户提供高品质的物业服务

主要负责：1. 负责各版本需求迭代，高质量高保真输出UI与需求；

2、描述：

### 三. 构建工具

#### Gulp是web开发中帮助你自动完成任务的工具，基于Nodejs Stream 流的批量处理工具

> Gulp的核心：
>
> 1. 如何制定一套合理、可配置、能够真正提升我们工作效率的构建流程
> 2. 如何在需要某个功能时，能够快速找到最合适的那个插件，且能够快速使用
>
> Gulp的特点：
>
> + 万事皆任务
> + 基于NodeJs数据流

+ 启动Web Server
+ 当文件修改保存后，自动刷新浏览器
+ 批量处理Sass或者Less文件
+ babel转ES11高级版本到Es5
+ 优化资源Css、Javascript、Images

#### 使用方式

1. 全局安装gulp-cli: `npm i -g gulp-cli`

2. 局部安装：`npm i glup --save-dev`

3. 创建默认任务`gulpfile.js`

4. 创建copy任务

   > gulp暴露了src()和dest()方法用于处理计算机上存放的文件
   >
   > + src()进行文件读入： 选择需要的文件，读取内存种并通过流进行处理
   > + dest()进行输出文件：将文件存在系统目录内

5. 

   ```
   // 
   
   ```

### 框架内：Vue、React(核心)

#### Vue

##### 1.0 Vue生命周期

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c465f7a98b433c9c4efbf1247efda2~tplv-k3u1fbpfcp-watermark.image)

##### 1.1 数据双向绑定原理（数据驱动视图）

>  **UI = render(state)**: 状态state是输入，页面UI是输出，状态输入一旦变了，页面输出也随之而改变，这种特性就是数据驱动试图

+ 变化侦察： 追踪状态 。

  **angular**中是通过脏值检测流程来实现变化侦察；

  **react**中是通过对比虚拟Dom来实现变化侦测

  **vue**中是使用`Object.defineProperty`来检测

  + `Object.defineProperty`检测数据更新（**针对Object的变化侦测**）

    > vue源码中定义了一个Observer类，它将一个正常的object转换为可检测的object,并且给value新增一个__ob__属性，值为value的Observer实例。这个操作相当于为value打上了标记，表示它已经被转化为响应式了，可避免重复操作.

    ```js
    // 源码位置：src/core/observer/index.js
    /**
     * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
     */
     export class Observer {
     	constructor(value) {
     		this.value = value;
     		def(value, '__ob__', this)
     		if(Array.isArray(value)){
     			// 处理value是数组的逻辑
     		} else {
     			this.walk(value)
     		}
     	}
     	walk(obj: Object){
     		const keys = Object.keys(obj)
     		for(let key= 0; key < keys.length, key++) {
     			defineReactive(obj, keys[i])
     		}
     	}
     }
     defineReactive(obj, key, val) {
     	// 如果只传了obj和key,那么val = obj[key]
     	if(arguments.length === 2) {
     		val = obj[key]
     	}
     	if(typeof val === 'object') {
     		new Observer(val)
     	}
     	Object.defineProperty(obj, key, {
     		enumerable: true,
     		configurable: true,
     		get: function() {
     			return val
     		}, 
     		set: function(newVal) {
     			if(val === newVal) {
                     return
     			}
     			val = newVal
     		}
     	})
     }
    ```

  + 依赖收集：使用者使用了这个数据（即依赖了这个数据），每个数据都有一个依赖数组，谁依赖了这个数据，我们就把这个数据放到这个依赖数组中，当数据发生变化时，就去它对应的依赖数组依次通知。**在getter中收集依赖，在setter中通知依赖更新**

  + 依赖收集到了哪里？ 给每个数据建立一个**依赖管理器**，然后把这个数据的所有依赖都管理起来

    ```js
    // 源码位置：src/core/observe/dep.js
    exports default class Dep{
    	constructor() {
            this.subs = [] // 存放依赖
        }
        // 新增
        addSub(sub) {
    		this.subs.push(sub)
        }
    	// 删除一个依赖
    	removeSub(sub) {
            remove(this.subs, sub)
        }
    	// 添加一个依赖
    	depend(sub) {
            if(window.target) {
                this.addSub(window.target)
            }
        }
    	// 通知所有依赖
    	notify() {
            const subs = this.subs.slice()
            for(let i=0; l=subs.length, i< l, i++) {
                subs[i].update()
            }
        }
    }
    // 删除单个项
    export function remove(arr, item) {
        if(arr.length) {
            const index = arr.indexOf(item)
            if(index > -1) {
                return arr.splice(index, 1)
            }
        }
    }
    ```

    有了依赖器之后，可在getter中收集依赖，setter中通知依赖更新

    ```js
    function defineReative(obj, key, val) {
        if(arguments.length === 2) {
            val = obj[key]
        }
        if(typeof obj === 'object') {
            new Observer(val)
        }
        const dep = new Dep();
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function() {
                dep.depend(val)
                return val
            },
            set: function(newVal) {
                if(val === newVal) {
                    return
                }
                val = newVal
                dep.notify()
            }
        })
    }
    ```

    + 实际依赖：谁使用了数据，谁就是依赖，我们就为之创建一个`watcher`实例。在创建`watcher`实例的过程中自动会把自己添加到数据对应的依赖管理器中，以后这个`watcher`实例就代表这个依赖，当数据变化时，我们就通知这个`watcher`实例，由`watcher`实例再去通知真正的依赖

    + **总结**：`watcher`先把自己设置到全局唯一指定位置（window.target）,然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着，在`getter`中就会从全局唯一的那个位置读取正在读取数据的`watcher`，并把这个`watcher`收集到`Dep`中。收集好之后，当数据发生变化时，会向`Dep`中每个`watcher`发送通知。通过这样的方式，`watcher`可以主动去订阅任意一个数据的变化。如图所示

      ![img](https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg)

    + **以上方式的缺点：**Object.defineProperty虽然实现了对对象数据的取值和设置值，但是在向object中添加key/value键值对或者删除一对已有的key/value键值对时，它是无法检测到的。针对这一问题Vue提供了`vue.set`和`vue.delete`方法通知视图更新

  + **总结流程**

    1. `Data`通过`Observer`转换成了`getter\setter`的形式来追踪变化
    2. 当外界通过`watcher`读取数据时，会触发`getter` 从而将`watcher`添加到依赖。
    3. 当数据方式变化时，会触发`setter`,从而向`Dep`中依赖（即`Watcher`）发送通知。
    4. `Watcher`接收到通知后，会向外界发送通知，变化通知到外界可能会触发视图更新，也可能出发用户的某个回调函数等等

  + **Array的变化检测**：在获取数据时收集依赖，数据变化时依赖更新

    + 数组无法使用`Object.defineProperty`方法，但是在Vue中我们定义数组时其实也是放在一个`object`对象中，只要在这个`object`数据对象中获取这个数组的数组就会触发`getter`,即可在`getter`中收集依赖

    + Vue中创建了一个数组方法拦截器，它拦截在数组实例与`Array.property`之间，在拦截器内重写了操作数据的一些方法，当数组实例使用操作数组方法时，其实使用的就是拦截器重写的方法，而不在使用`Array.prototype`上的原生方法

      ![img](https://vue-js.com/learn-vue/assets/img/2.b446ab83.png)

      `Array`原型中可以改变数组自身内容的方法有7个：`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`

      ```js
      // 源码地址：src/core/observer/array.js
      const arrayProto = Array.prototype;
      // 创建一个拦截器
      export const arrayMethods = Object.create(arrayProto)
      // 改变数组自身内容的7个方法
      const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
      methodsToPatch.forEach(method => {
          const original = arrayProto[method] // 缓存原生方法
          Object.defineProperty(arrayMethods, method, {
              enmuerable: false,
              configurable: true,
              widthable,
              value: function mutator(...args) {
                  const result = original.apply(this, args)
                  return result
              }
          })
      })
      
      ```

      

  

##### 1.2 Virtual DOM 原理以及diff算法

> + Virtual DOM: 虚拟DOM，用一个`js`对象来描述一个`DOM`节点
>
> + 为什么需要虚拟DOM： vue是数据驱动视图，数据发生变化视图就要随之发生变化，在更新视图的时候难免会操作DOM，而操作真实Dom是非常耗费性能，一个真正的DOM是非常庞大的
> + 产生的原因和最大的用途：使用js模拟出的一个dom节点，称之为虚拟dom节点。当数据发生变化时，我们对比变化前后的虚拟dom节点，通过`DOM-diff`算法计算出需要更新的地方，然后再去更新需要更新的视图

+ **Vnode类**

  ```js
  // /源码地址： src/core/vdom/vnode.js
  export default class VNode {
    constructor (
      tag?: string,
      data?: VNodeData,
      children?: ?Array<VNode>,
      text?: string,
      elm?: Node,
      context?: Component,
      componentOptions?: VNodeComponentOptions,
      asyncFactory?: Function
    ) {
      this.tag = tag                                /*当前节点的标签名*/
      this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
      this.children = children  /*当前节点的子节点，是一个数组*/
      this.text = text     /*当前节点的文本*/
      this.elm = elm       /*当前虚拟节点对应的真实dom节点*/
      this.ns = undefined            /*当前节点的名字空间*/
      this.context = context          /*当前组件节点对应的Vue实例*/
      this.fnContext = undefined       /*函数式组件对应的Vue实例*/
      this.fnOptions = undefined
      this.fnScopeId = undefined
      this.key = data && data.key           /*节点的key属性，被当作节点的标志，用以优化*/
      this.componentOptions = componentOptions   /*组件的option选项*/
      this.componentInstance = undefined       /*当前节点对应的组件的实例*/
      this.parent = undefined           /*当前节点的父节点*/
      this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
      this.isStatic = false         /*静态节点标志*/
      this.isRootInsert = true      /*是否作为跟节点插入*/
      this.isComment = false             /*是否为注释节点*/
      this.isCloned = false           /*是否为克隆节点*/
      this.isOnce = false                /*是否有v-once指令*/
      this.asyncFactory = asyncFactory
      this.asyncMeta = undefined
      this.isAsyncPlaceholder = false
    }
  
    get child (): Component | void {
      return this.componentInstance
    }
  }
  ```

  上面的代码可以看出：`Vnode`类中包含了描述一个真实`DOM`节点所需要的一系列属性，如`tag`表示节点标签名，`text`表示节点包含的文本，`children`表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实`DOM`节点

+ **Vnode类型：** 注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点

  1. **注释节点**：只需要两个属性

     ```js
     // 创建注释节点
     export const createEmptyVNnode = (text: string) {
     	const node = new VNode()
     	node.text = text; // 具体的注释信息
     	node.isComment = true; // 标识一个节点是否是注释节点
     	return node
     }
     ```

  2. **文本节点**：描述比注释节点更简单，只需要一个属性，`text`属性：用来表示具体的文本信息

     ```js
     // 创建文本节点
     export function createTextVNode(val: string | number) {
         return new VNode(underfind, underfind, underfind, String(val))
     }
     ```

  3. **克隆节点**：把一个已经存在的几点复制一份出来，它主要是为了做模板编译优化时使用, 现有节点与新克隆等到的几点唯一的区别时`isCloned`为`true`

     ```js
     // 创建克隆节点
     export function cloneVNode (vnode: VNode): VNode {
       const cloned = new VNode(
         vnode.tag,
         vnode.data,
         vnode.children,
         vnode.text,
         vnode.elm,
         vnode.context,
         vnode.componentOptions,
         vnode.asyncFactory
       )
       cloned.ns = vnode.ns
       cloned.isStatic = vnode.isStatic
       cloned.key = vnode.key
       cloned.isComment = vnode.isComment
       cloned.fnContext = vnode.fnContext
       cloned.fnOptions = vnode.fnOptions
       cloned.fnScopeId = vnode.fnScopeId
       cloned.asyncMeta = vnode.asyncMeta
       cloned.isCloned = true
       return cloned
     }
     ```

  4. **元素节点**：这种类型的节点更贴近我们通常看到的真实`DOM`节点，它具有描述节点标签名词的`tag`属性，描述节点属性如：`class`、`attrbutes`等的`data`属性，有描述包含的子节点信息的	`children`属性等。由于元素节点包含的情况比较复杂，所以源码中没有直接写死

     ```js
     // 真实DOM节点
     <div id='a'><span>难凉热血</span></div>
     
     // VNode节点
     {
       tag:'div',
       data:{},
       children:[
         {
           tag:'span',
           text:'难凉热血'
         }
       ]
     }
     ```

  5. **组件节点：**组件节点 出了有元素节点具有的属性之外，它还有两个特有的属性：

     + componentOptions: 组件的option选项，如组件的`props`等
     + componentInstance：当前组件节点对应的`Vue`实例

  6. **函数式组件节点**：函数式组件节点相较于组件节点，它又有两个特有的属性：】

     + fnContext：函数式组件对应的Vue实例
     + fnOptions：组件的option选项

+ **VNode总结**

  以js的计算性能来换取操作真实`DOM`所消耗的性能。在Vue中是通过VNode类来实例化出不同类型的虚拟dom节点，并且学习了不同类型节点生产的属性不同，所谓不同类型的节点其本质还是一样的呃，都是Vnode类的实例，只是在实例化时传入的属性参数不同罢了。VNode的作用，有了数据变化前后的VNode,我们才能进行后续的`DOM-diff`找出 差异，最后做到只更新有差异的视图，从而达到尽可能少的操作真实`DOM`的目的，以节省性能。
  
+ ##### **DOM-diff算法**

  > DOM-diff过程： VNode的最大用途就是在数据变化前后生成真实DOM对应的虚拟DOM节点,然后对比新旧两份VNode，找出差异所在，然后更新有差异的`DOM`节点，最终达到以最少操作真实`DOM`更新视图的目的。而对比新旧两份VNode并找出差异的过程就是`DOM-diff`过程

  1. patch：其实就是DOM-diff过程，即对旧的VNode修补，打补丁从而得到新得VNode(**对比新旧两份`VNode`的过程，以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch要干的事情**) ，其实只干了三件事情：

     1. 创建节点：新的`VNode`中有而旧的`vnode`中没有，就在旧的`VNode`中创建；

        > Vnode可以描述6种类型的节点，实际中只有三种类型(**元素节点、文本节点、注释节点**)的节点可以被创建并插入到`DOM`，vue在创建节点的时候就会判断在新的`vnode`中有而	旧的`vnode`中没有的节点属于那种类型的节点，从而调用不同的方法创建并插入到DOM中

        ```js
        // 源码位置: /src/core/vdom/patch.js
        function createElm (vnode, parentElm, refElm) {
            const data = vnode.data
            const children = vnode.children
            const tag = vnode.tag
            if (isDef(tag)) {
              	vnode.elm = nodeOps.createElement(tag, vnode)   // 创建元素节点
                createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点
                insert(parentElm, vnode.elm, refElm)       // 插入到DOM中
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps.createComment(vnode.text)  // 创建注释节点
              insert(parentElm, vnode.elm, refElm)           // 插入到DOM中
            } else {
              vnode.elm = nodeOps.createTextNode(vnode.text)  // 创建文本节点
              insert(parentElm, vnode.elm, refElm)           // 插入到DOM中
            }
          }
        ```

        + 判断是否为元素节点只需要判断`VNode`节点是否有`tag`标签即可，若有则认为是元素节点，则调用`createElement`方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后`insert`插入到当前元素节点里面，最后把当前元素节点插入到`DOM`中

        + 判断是否为注释节点，只需判断`VNode`的`isComment`属性是否为`true`。若为`true`则为注释节点，就调用`createComment`方法创建注释节点，再插入到`DOM`中。

        + 如果既不是元素节点又不是注释节点，那就认为是文本节点，则调用`createTextNode`方法创建文本节点，再插入到`DOM`中

          > 代码中的`nodeOps`是`vue`为了跨平台兼容性，对所有节点操作进行了封装，例如：`nodeOps.createTextNode()`在浏览器端等同于`document.createTextNode()`

          ![img](https://vue-js.com/learn-vue/assets/img/2.02d5c7b1.png)

     2. 删除节点：新的`VNode`中没有而旧的`vnode`中有，就在旧的`VNode`中删除；

        > 如果某些节点再新的`VNode`中没有而在旧的`oldVNode`中有，那么就需要把这些节点从旧的`oldVNode`中删除。删除节点非常简单，只需在要删除节点的父元素上调用`removeChild`方法即可

        ```js
        function removeNode (el) {
            const parent = nodeOps.parentNode(el)  // 获取父节点
            if (isDef(parent)) {
              nodeOps.removeChild(parent, el)  // 调用父节点的removeChild方法
            }
          }
        ```

        

     3. 更新节点：新的`VNode`和旧的`vnode`中都有，就以新的`VNode`为准，更新旧的`VNode`

        > 当某些节点在新的`VNode`和旧的`oldVNode`中都有时，我们就需要细致比较一下，找出不一样的地方进行更新
        >
        > **静态节点**：该节点只包含了纯文字，没有任何可变的变量，不论数据如何变化，只要这个节点第一次渲染了，那么它以后都不会在发生变化了，数据发生任何变化都与他无关

        ```js
        // 更新节点
        function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
          // vnode与oldVnode是否完全一样？若是，退出程序
          if (oldVnode === vnode) {
            return
          }
          const elm = vnode.elm = oldVnode.elm
        
          // vnode与oldVnode是否都是静态节点？若是，退出程序
          if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
          ) {
            return
          }
        
          const oldCh = oldVnode.children
          const ch = vnode.children
          // vnode有text属性？若没有：
          if (isUndef(vnode.text)) {
            // vnode的子节点与oldVnode的子节点是否都存在？
            if (isDef(oldCh) && isDef(ch)) {
              // 若都存在，判断子节点是否相同，不同则更新子节点
              if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
            }
            // 若只有vnode的子节点存在
            else if (isDef(ch)) {
              /**
               * 判断oldVnode是否有文本？
               * 若没有，则把vnode的子节点添加到真实DOM中
               * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中
               */
              if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
            }
            // 若只有oldnode的子节点存在
            else if (isDef(oldCh)) {
              // 清空DOM中的子节点
              removeVnodes(elm, oldCh, 0, oldCh.length - 1)
            }
            // 若vnode和oldnode都没有子节点，但是oldnode中有文本
            else if (isDef(oldVnode.text)) {
              // 清空oldnode文本
              nodeOps.setTextContent(elm, '')
            }
            // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么
          }
          // 若有，vnode的text属性与oldVnode的text属性是否相同？
          else if (oldVnode.text !== vnode.text) {
            // 若不相同：则用vnode的text替换真实DOM的文本
            nodeOps.setTextContent(elm, vnode.text)
          }
        }
        ```

        ​	![img](https://vue-js.com/learn-vue/assets/img/3.7b0442aa.png)

     1. 如果`VNode`和`oldVNode`均为静态节点， 直接ruturn

     2.  如果`VNode`是文本节点:

        a. 如果`oldVNode`也是文本节点，比较两者文本不相同，则把`oldVNode`里的文本改成跟`VNode`的文本一样;

        b. 如果`oldVNode`不是文本节点，那么不论它是什么，直接调用`setTextNode`方法把它改成文本节点，并且文本内容跟`VNode`相同

     3. 如果`VNode`是元素节点：

        + 该节点包含子节点（🔶🔶🔶🔶）

          如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。

        + 该节点不包含子节点

          如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。

     4. `VNode`是元素节点包含了子节点（**更新子节点**）

        当新的`VNode`与旧的`VNode`都是元素节点且都包含子节点时，那么这两个节点的`VNode`实例上的children属性是包含的子节点数组，新`VNode`的子节点为`newchildren`, 旧`VNode`的子节点为`oldChildren`，外层循环`newchildren`内层循环`oldChildren`，这个过程会出现四种情况：

        + **创建子节点**：如果`newchildren`里面的某个子节点在`oldChildren`里面找不到相同的子节点，那么说明这个节点是之前没有的，所有需要新增这个节点，即创建节点；（**合适的位置是所有未处理节点之前，而并非所有已处理节点之后**）

        + **删除子节点**：如果`newchildren`循环完毕后，`oldChildren`里面还有未处理的子节点，那说明这些节点是要被废弃的，处理删除即可

        + **移动子节点：**如果`newchildren`里面的某个子节点在`oldChildren`里面找到了相同节点，但是所处位置不同，那么需要以`newchildren`里面的子节点为基准，调整`oldChildren`里该节点的位置，使之与在`newchildren`的位置相同

        + **更新子节点：**如果`newchildren`里面的某个子节点在`oldChildren`里面找到了相同节点，且所处位置也是相同，那么直接在`oldChildren`中更新该节点，使之与`newChildren`里的该节点相同

          ```js
          // 源码位置： /src/core/vdom/patch.js
          if (isUndef(idxInOld)) {    // 如果在oldChildren里找不到当前循环的newChildren里的子节点
              // 新增节点并插入到合适位置
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          } else {
              // 如果在oldChildren里找到了当前循环的newChildren里的子节点
              vnodeToMove = oldCh[idxInOld]
              // 如果两个节点相同
              if (sameVnode(vnodeToMove, newStartVnode)) {
                  // 调用patchVnode更新节点
                  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
                  oldCh[idxInOld] = undefined
                  // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动
                  canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
              }
          }
          ```

          ```js
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          // 等同于
          if(canMove){
              nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          }
          ```

     5. **优化更新子节点**（🔶🔶🔶🔶🔶🔶🔶🔶）

        > 内外侧循环可解决一部分问题，但是存在当包含子节点数量很多时。这样循环算法的事件复杂度就会变的很大，不利于性能提升，vue对此进行了优化升级

        1. 优化策略

           按照旧方法会存在算法时间复杂度就会非常高，不利于性能提升

           优化策略可以不用按照顺序去循环`newChildren`和`oldChildren`这两个数组，可以先比较这两个数组里特殊位置的子节点（**从两边向中间找**）

           ![img](https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png)

           + `newChildren`数组里的所有未处理子节点的第一个子节点称为：**新前**；
           + `newChildren`数组里的所有未处理子节点的最后一个子节点称为：**新后**；
           + `oldChildren`数组里的所有未处理子节点的第一个子节点称为：**旧前**；
           + `oldChildren`数组里的所有未处理子节点的最后一个子节点称为：**旧后**；

           1. ## 新前与旧前

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/9.e017b452.png)

           2. ## 新后与旧后

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。

              ![img](https://vue-js.com/learn-vue/assets/img/10.cf98adc0.png)

           3. ## 新后与旧前

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/11.2ddb5ee5.png)

              此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，**更新节点要以新`VNode`为基准，然后操作旧的`oldVNode`，使之最后旧的`oldVNode`与新的`VNode`相同**。那么现在的情况是：`newChildren`数组里的最后一个子节点与`oldChildren`数组里的第一个子节点相同，那么我们就应该在`oldChildren`数组里把第一个子节点移动到最后一个子节点的位置，如下图：

              ![img](https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png)

              从图中不难看出，我们要把`oldChildren`数组里把第一个子节点移动到数组中**所有未处理节点之后**。

              如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。

           4. ## 新前与旧后

              把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/13.98dbc208.png)

              同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是`newChildren`数组里的第一个子节点与`oldChildren`数组里的最后一个子节点相同，那么我们就应该在`oldChildren`数组里把最后一个子节点移动到第一个子节点的位置，如下图：

              ![img](https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png)

              从图中不难看出，我们要把`oldChildren`数组里把最后一个子节点移动到数组中**所有未处理节点之前**。

              OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。

           5. ## 源码

              ```js
              // 循环更新子节点
                function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                  let oldStartIdx = 0               // oldChildren开始索引
                  let oldEndIdx = oldCh.length - 1   // oldChildren结束索引
                  let oldStartVnode = oldCh[0]        // oldChildren中所有未处理节点中的第一个
                  let oldEndVnode = oldCh[oldEndIdx]   // oldChildren中所有未处理节点中的最后一个
              
                  let newStartIdx = 0               // newChildren开始索引
                  let newEndIdx = newCh.length - 1   // newChildren结束索引
                  let newStartVnode = newCh[0]        // newChildren中所有未处理节点中的第一个
                  let newEndVnode = newCh[newEndIdx]  // newChildren中所有未处理节点中的最后一个
              
                  let oldKeyToIdx, idxInOld, vnodeToMove, refElm
              
                  // removeOnly is a special flag used only by <transition-group>
                  // to ensure removed elements stay in correct relative positions
                  // during leaving transitions
                  const canMove = !removeOnly
              
                  if (process.env.NODE_ENV !== 'production') {
                    checkDuplicateKeys(newCh)
                  }
              
                  // 以"新前"、"新后"、"旧前"、"旧后"的方式开始比对节点
                  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                    if (isUndef(oldStartVnode)) {
                      oldStartVnode = oldCh[++oldStartIdx] // 如果oldStartVnode不存在，则直接跳过，比对下一个
                    } else if (isUndef(oldEndVnode)) {
                      oldEndVnode = oldCh[--oldEndIdx]
                    } else if (sameVnode(oldStartVnode, newStartVnode)) {
                      // 如果新前与旧前节点相同，就把两个节点进行patch更新
                      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
                      oldStartVnode = oldCh[++oldStartIdx]
                      newStartVnode = newCh[++newStartIdx]
                    } else if (sameVnode(oldEndVnode, newEndVnode)) {
                      // 如果新后与旧后节点相同，就把两个节点进行patch更新
                      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
                      oldEndVnode = oldCh[--oldEndIdx]
                      newEndVnode = newCh[--newEndIdx]
                    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                      // 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后
                      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
                      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
                      oldStartVnode = oldCh[++oldStartIdx]
                      newEndVnode = newCh[--newEndIdx]
                    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                      // 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前
                      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
                      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
                      oldEndVnode = oldCh[--oldEndIdx]
                      newStartVnode = newCh[++newStartIdx]
                    } else {
                      // 如果不属于以上四种情况，就进行常规的循环比对patch
                      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
                      idxInOld = isDef(newStartVnode.key)
                        ? oldKeyToIdx[newStartVnode.key]
                        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
                      // 如果在oldChildren里找不到当前循环的newChildren里的子节点
                      if (isUndef(idxInOld)) { // New element
                        // 新增节点并插入到合适位置
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                      } else {
                        // 如果在oldChildren里找到了当前循环的newChildren里的子节点
                        vnodeToMove = oldCh[idxInOld]
                        // 如果两个节点相同
                        if (sameVnode(vnodeToMove, newStartVnode)) {
                          // 调用patchVnode更新节点
                          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
                          oldCh[idxInOld] = undefined
                          // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动
                          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
                        } else {
                          // same key but different element. treat as new element
                          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                        }
                      }
                      newStartVnode = newCh[++newStartIdx]
                    }
                  }
                  if (oldStartIdx > oldEndIdx) {
                    /**
                     * 如果oldChildren比newChildren先循环完毕，
                     * 那么newChildren里面剩余的节点都是需要新增的节点，
                     * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中
                     */
                    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
                    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
                  } else if (newStartIdx > newEndIdx) {
                    /**
                     * 如果newChildren比oldChildren先循环完毕，
                     * 那么oldChildren里面剩余的节点都是需要删除的节点，
                     * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除
                     */
                    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
                  }
                }
              ```

              优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环

              ![img](https://vue-js.com/learn-vue/assets/img/15.e9bdf5c1.png)

              + **newStartIdx:**`newChildren`数组里开始位置的下标；
              + **newEndIdx:**`newChildren`数组里结束位置的下标；
              + **oldStartIdx:**`oldChildren`数组里开始位置的下标；
              + **oldEndIdx:**`oldChildren`数组里结束位置的下标；

              **优化策略是新旧节点两两更新，一次更新将会移动两个节点：`newStartIdx`和`oldStartIdx`只能往后移动（只会加），`newEndIdx`和`oldEndIdx`只能往前移动（只会减）**

              当开始位置大于结束位置时，表示所有节点都已经遍历过了

              1. 如果`oldStartVnode`不存在，则直接跳过，将`oldStartIdx`加1，比对下一个

                 ```js
                 // 以"新前"、"新后"、"旧前"、"旧后"的方式开始比对节点
                 while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                 	if (isUndef(oldStartVnode)) {
                         oldStartVnode = oldCh[++oldStartIdx]
                       }
                 }
                 ```

              2. 如果`oldEndVnode`不存在，则直接跳过，将`oldEndIdx`减1，比对前一个

                 ```js
                 else if (isUndef(oldEndVnode)) {
                     oldEndVnode = oldCh[--oldEndIdx]
                 }
                 ```

              3. 如果新前与旧前节点相同，就把两个节点进行`patch`更新，同时`oldStartIdx`和`newStartIdx`都加1，后移一个位置

                 ```js
                 else if (sameVnode(oldStartVnode, newStartVnode)) {
                     patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
                     oldStartVnode = oldCh[++oldStartIdx]
                     newStartVnode = newCh[++newStartIdx]
                 }
                 ```

              4. 如果新后与旧后节点相同，就把两个节点进行`patch`更新，同时`oldEndIdx`和`newEndIdx`都减1，前移一个位置

                 ```js
                 else if (sameVnode(oldEndVnode, newEndVnode)) {
                     patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
                     oldEndVnode = oldCh[--oldEndIdx]
                     newEndVnode = newCh[--newEndIdx]
                 }
                 ```

              5. 如果新后与旧前节点相同，先把两个节点进行`patch`更新，然后把旧前节点移动到`oldChilren`中所有未处理节点之后，最后把`oldStartIdx`加1，后移一个位置，`newEndIdx`减1，前移一个位置

                 ```js
                 else if (sameVnode(oldStartVnode, newEndVnode)) {
                     patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
                     canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
                     oldStartVnode = oldCh[++oldStartIdx]
                     newEndVnode = newCh[--newEndIdx]
                 }
                 ```

              6. 如果新前与旧后节点相同，先把两个节点进行`patch`更新，然后把旧后节点移动到`oldChilren`中所有未处理节点之前，最后把`newStartIdx`加1，后移一个位置，`oldEndIdx`减1，前移一个位置

                 ```js
                 else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                     patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
                     canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
                     oldEndVnode = oldCh[--oldEndIdx]
                     newStartVnode = newCh[++newStartIdx]
                 }
                 ```

              7. 如果不属于以上四种情况，就进行常规的循环比对`patch`

              8. 如果在循环中，`oldStartIdx`大于`oldEndIdx`了，那就表示`oldChildren`比`newChildren`先循环完毕，那么`newChildren`里面剩余的节点都是需要新增的节点，把`[newStartIdx, newEndIdx]`之间的所有节点都插入到`DOM`中

                 ```js
                 if (oldStartIdx > oldEndIdx) {
                     refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
                     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
                 }
                 ```

              9. 如果在循环中，`newStartIdx`大于`newEndIdx`了，那就表示`newChildren`比`oldChildren`先循环完毕，那么`oldChildren`里面剩余的节点都是需要删除的节点，把`[oldStartIdx, oldEndIdx]`之间的所有节点都删除

                 ```js
                 else if (newStartIdx > newEndIdx) {
                     removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
                 }
                 ```

                 

              10. 总结：Vue为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前和旧后，新后和旧后，新后和旧前，新前和旧后。



##### 1.2.1 diff 算法总结

1. 源码分析：必要性，**lifecycle.js**:  ` mountComponent()`

2. 组件中可能存在很多个data中key使用

3. 源码分析2：执行方式，**patch.js** :  `patchVnode()`

4. `patchVnode`是diff发生的地方，整体策略：**深度优先、同层比较**

5. 源码分析3：高效性，**patch.js**：`updateChildren()` 更新子节点-diff核心方法

   > diff算法核心，采用双指针的方式，对比新老vnode的子节点
   >
   > 具体步骤如下：
   >
   > 1. tag标签不一致直接新节点替换旧节点
   > 2. tag标签一致情况：
   >    1. 进行属性替换；
   >    2. 比对子元素
   >       1. 新老节点都有子节点 采用双指针方式比对`sameVnode`判断key与tag完全相同则为同一个节点，进行节点复用；
   >          1. 进行新头和旧头比较、新尾和旧尾比较、新头和旧尾、新尾和旧头比较 : sameNode的时候传入两个新老子节点`path(oldChild , newChild)` 递归创建真实节点替换老的节点
   >          2. 乱序情况--以上情况都不符合：先遍历旧子节点数组形成key值映射的map对象(映射表)，然后根据子节点数组循环，按照key值和index位置关系移动以及新增节点  最后删除多余的旧子节点 ， 如果移动旧节点同样需要`path(oldChild , newChild)` 递归创建真实节点替换老的节点
   >       2. 新节点有子节点而旧节点无子节点，则直接将该子节点虚拟节点转化为真实节点插入即可
   >       3. 新节点无子节点而旧节点有，则直接清空innerHtml
   > 3. 无tag标签-文本节点直接比较内容是否一致

   https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f964567d4dbc4228bf9bdbdb4ad70c06~tplv-k3u1fbpfcp-watermark.image

   

> 

##### 1.3 模板编译

> 把用户在`<template></template>`标签中写的类似于原生`html`的内容进行编译，把原生`html`的内容找出来，再把非原生`html`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数的这一段过程称为模板编译过程

###### 1.3.1 整体渲染流程

所谓渲染流程，就是吧用户写的类似于原生`html`的模板经过一系列处理最终反应到视图称之为整个渲染流程

![img](https://vue-js.com/learn-vue/assets/img/1.f0570125.png)

###### 1.3.2 模板编译内部流程

1. 抽象语法书AST

   > 抽象语法树：在计算机科学中，**抽象语法树**（**A**bstract**S**yntax**T**ree，AST），或简称**语法树**（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是抽象的，是因为这里的语法并不会表示出真实语法中出现的每个细节

![img](https://vue-js.com/learn-vue/assets/img/2.5596631a.png)

2. 具体流程

   将一堆字符串模板解析成抽象语法树`AST`后，可对其进行各种操作处理，处理完后用处理后的`AST`来生成`render`函数。具体流程分为三大阶段：

   1. 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树`AST`；
   2. 优化阶段：遍历`AST`，找到其中的静态节点，并打上标记；
   3. 代码生成阶段：将`AST`转换成渲染函数

   这三个阶段在源码中分别对应三个模块，对应源码路径为：

   1. 模板解析阶段——解析器——源码路径：`src/compiler/parser/index.js`;

   2. 优化阶段——优化器——源码路径：`src/compiler/optimizer.js`;

   3. 代码生成阶段——代码生成器——源码路径：`src/compiler/codegen/index.js`;

      ```js
      // 源码位置: /src/complier/index.js
      export const createCompiler = createCompilerCreator(function baseCompile (
        template: string,
        options: CompilerOptions
      ): CompiledResult {
        // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST
        const ast = parse(template.trim(), options)
        if (options.optimize !== false) {
          // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；
          optimize(ast, options)
        }
        // 代码生成阶段：将AST转换成渲染函数；
        const code = generate(ast, options)
        return {
          ast,
          render: code.render,
          staticRenderFns: code.staticRenderFns
        }
      })
      ```

      可以看到`baseCompole`代码非常的简短主要核心代码

      + **const ast =parse(template.trim(), options)** ：`parse`会用正则等方式解析  `template`模板中的指令、`class`、`style`等数据，形成`AST`;
      + **optimize(ast, options)**：`optimize`的主要作用是标记静态节点，这是在编译过程中的一处优化，挡在进行`patch`的过程中，`DOM-Diff`算法会直接跳过静态节点，从而减少了比较过程，优化了`patch`的性能；
      + **const code =generate(ast, options)**：将 `AST` 转化成 `render`函数字符串的过程，得到结果是 `render`函数 的字符串以及 `staticRenderFns` 字符串；

      最终`baseCompile`的返回值：

      ```js
      {
       	ast: ast,
       	render: code.render,
       	staticRenderFns: code.staticRenderFns
       }
      ```

      最终返回了抽象语法树`AST`,渲染函数（render），静态渲染函数（staticRenderFns）,且`render`的值为`code.render`,`staticRenders`的值为`code.staticRenderFns`，也就是说通过`generate`处理`ast`之后得到的返回值`code`是一个对象，具体流程图如下：

      ![img](https://vue-js.com/learn-vue/assets/img/3.15d9566b.png)

      **总结**：为什么会有模板编译，因为有了模板编译，才有了虚拟`DOM`，才会有后续的视图更新

3. 模板编译解析整体流程

   >解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成`AST`。我们知道在`<template></template>`模板内，除了有常规的`HTML`标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规`HTML`的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器

   ![img](https://vue-js.com/learn-vue/assets/img/4.16462ada.png)

   解析器源码位置：`/src/complier/parser`文件夹下，其主线代码如下：

   ```js
   // 代码位置：/src/complier/parser/index.js
   
   /**
    * Convert HTML string to AST.
    */
   export function parse(template, options) {
      // ...
     parseHTML(template, {
       warn,
       expectHTML: options.expectHTML,
       isUnaryTag: options.isUnaryTag,
       canBeLeftOpenTag: options.canBeLeftOpenTag,
       shouldDecodeNewlines: options.shouldDecodeNewlines,
       shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
       shouldKeepComment: options.comments,
       start (tag, attrs, unary) {
   
       },
       end () {
   
       },
       chars (text: string) {
   
       },
       comment (text: string) {
   
       }
     })
     return root
   }
   ```

   从上面代码中可以看到，`parse` 函数就是解析器的主函数，在`parse` 函数内调用了`parseHTML` 函数对模板字符串进行解析，在`parseHTML` 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器`parseText`函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器`parseFilters`函数进行解析。

   **总结：**模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为**HTML解析器**，**文本解析器**和**过滤器解析器**。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数`parse`中先调用HTML解析器`parseHTML`函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。

   ##### **1. HTML解析器**

   > 主要负责解析出模板字符串有哪些内容，然后根据不同的内容才能调用其他解析器以及做相应的处理

   在源码中，`HTML`解析器就是`parseHTML`函数，在模板解析主线函数`parse`中调用了该函数，并传入两个参数，代码如下：

   ```js
   // 代码位置：/src/complier/parser/index.js
   /**
    * Convert HTML string to AST.
    * 将HTML模板字符串转化为AST
    */
   export function parse(template, options) {
      // ...
     parseHTML(template, {
       warn,
       expectHTML: options.expectHTML,
       isUnaryTag: options.isUnaryTag,
       canBeLeftOpenTag: options.canBeLeftOpenTag,
       shouldDecodeNewlines: options.shouldDecodeNewlines,
       shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
       shouldKeepComment: options.comments,
       // 当解析到开始标签时，调用该函数
       start (tag, attrs, unary) {
   
       },
       // 当解析到结束标签时，调用该函数
       end () {
   
       },
       // 当解析到文本时，调用该函数
       chars (text) {
   
       },
       // 当解析到注释时，调用该函数
       comment (text) {
   
       }
     })
     return root
   }
   ```

###### 1.3.3 编译原理总结

> 模板转化核心方法： 源码地址： *src/compiler/index.js*  `compileToFunctions `  

###### 1.4 minxin混入

> mixin 混入的特性：方法和参数在各个组件中不共享，虽然组件调用了mixins并将其属性合并到自身组件中来，但是其属性只会被当前组件中所识别并不会被共享，也就是其他组件无法从当前组件中获取到mixins中的数据和方法
>
> initGlobalApi(Vue) 初始化全局api
>
> 1. mixin ->全局混入 把传入的options选项混入到vue实例的options里面 一般作用是提取全局的公用方法或状态
> 2. 有默认的合并策略，父子都有且是对象就合并一起，父亲有儿子就用父亲 否则直接用儿子的合并策略
>    1. 生命周期的合并策略是合并成一个数组全部依次执行 `mergeHHHook`， **执行顺序：全局在前面、局部mixins在前、待混入的组件在后**

###### 1.5 组件原理

> vue中区分全局组件注册与局部组件注册
>
> + 全局组件注册 









+ nextTick实现原理
+ keep-alive实现原理

#### vue3.0相关

1. 响应式原理的改变，vue3.x使用proxy取代vue2.x版本的Object.defindProperty
   1. `Object.defindProperty`只能劫持对象的属性，需要遍历对象的每一个属性，如果属性值也是对象，则需要递归进行深度遍历，而Proxy是直接代理对象，不需要遍历操作；
   2. `Object.defindProperty` 对新增属性需要手动进行observe,因为这个方法劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再次使用`Object.defindProperty`进行劫持。也就是vue2.x中给数组和对象新增属性时，需要使用`$set`才能保证新增属性也是响应式，`$set`内部也是通过调用`Object.defindProperty`去处理的。
2. 组件选项申明方式vue3.x使用compositon API ，setup是vue3.x新增的一个选项，他是组件内使用composition API的入口
   1. composition API 包括`reactive`、`ref`、`toRefs`、`watch`、`watchEffect`、`computed`、生命周期钩子;
   2. setup执行时机是在`beforeCreate`之前执行;
   3. 
3. 模板语法变化 slot具名插槽语法  自定义指令  v-model升级
4. 其他方面的更改 Suspense 支持Fragment（多个根节点）和Protal（在dom其他部分渲染组件内容）组件，针对一些特殊场景做了处理。基于trees hacking优化，提供了非常丰富的内置功能

https://vue-js.com/learn-vue/reactive/object.html#_6-%E6%80%BB%E7%BB%93

参考链接：

https://juejin.cn/post/6940454764421316644

https://juejin.cn/post/6954173708344770591

