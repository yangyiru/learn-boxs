## 复习总结
### 一、js

#### 1. Es6语法知道那些？怎么用的？

+ **let**：块级变量声明，只在let命令所在的代码块（块级作用域）有效------暂时性死区（只要变量在let声明前使用，就会报错）
+ **const**：块级常量声明
+ **箭头函数**： sum = (a, b) => a + b; nums.forEach(item => console.log(item)) 
+ **解构赋值**：数组解构、对象解构
+ **扩展运算符**： {...xxx} 用于取出对象中的所有可遍历苏醒，拷贝到当前对象中；
+ **import(导入)**、**export(导出)**、**export defalut(默认导出)**；
+ **Object.assign()** 对象合并，将源对象的所有可枚举属性，复制到目标对象
+ **Symbol**：基本数据类型
+ **Set去重**
+ **promise对象**： 异步对象（可以从它那里获取异步操作的消息）三种状态：pedding(进行中)、fulfilled(已成功)、rejected(已失败)
+ **proxy**： 代理器
+ **async\await**：以简洁的方式编写基于promise的异步行为，避免链式调用promise
  特性列表整理（https://fangyinghang.com/es-6-tutorials/）

#### 2. Promise、Promise.all、Promise.race分别怎么用？

+ **promise的用法**（死记）

  ```js
  function fn() {
      return new Promise(resolve, reject) {
     		// 成功时执行resolve()
          // 失败时执行reject()
      }
  }
  ```

+ **promise.all**的用法（死记）

  ```js
  promise.all([promise1, promise2]).then(success, fail);
  // promise1与promise2都成功后才会执行success
  ```

+ **promise.race**的用法（死记）

  ```js
  promise.race([promise1, promise2]).then(success, fail);
  // promise1与promise2只要有一个成功就会调用成功
  // promise1与promise2只要有一个失败就会调用失败
  // 总之，谁第一个先成功或者失败，就认为是race的状态是成功或者失败
  ```

#### 3. 手写防抖函数与节流函数

> 防抖：一段时间内等待，所有的一起执行（例如：外卖员等待拿外卖）

```js
function debound(fn, time) {
    let timeId = null;
    return function() {
    	let const = this;
        if(timeId) windown.clearTimeout(timeId)
        timeId = setTimeout(() => {
            fn.apply(const, arguments)
            timeId = null
        }, time)
    }
}
```

> 节流：相同时间内执行一次后，第二次不会执行

```js
function throttly(fn, time) {
    let canUse = true;
    return function() {
        if(canUse) {
        	fn.apply(this, arguments);
            canUse = false;
            setTimeout(() => {
                canUse = true
            }, time)
        }
    }
}
```

#### 4. **手写AJAX**(背代码)

        1. 完整版
    
           ```js
           // 判断兼容性
           var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject();
           request.open('GET', '/a/b?name=1254', true);
           request.onreadystatechange = function() {
               if(request.readstate === 4 && request.status === 200) {
                   console.log(requset.responseText)
               }
           }
           request.send()
           ```

2. 简易版

   ```js
   // 判断兼容性
   var request = window.XMLHttpRequest ? new XMHttpRequest() : new ActiveXObject();
   request.open('GET', '/a/b?name=5656', true);
   request.load = function() {
       console.log(request.responseText)
   }
   request.send()
   ```

#### 5. 以下代码this指向是什么？

 1. 背代码

    **fn()**: this指向 **Windows/global**

    **obj.fn()**: this指向 **obj**
    **fn.call(xx)**: this指向**xxx 传入对象**
    **fn.apply(xx)**: this指向**xx 传入对象**
    **fn.bind(xx)**: this指向**xx 传入对象**
    **new Fn()**: this指向**实例对象**
    **fn = () =>{}**: this指向外面的this

    > 看调用 [《this 的值到底是什么？一次说清楚》](https://zhuanlan.zhihu.com/p/23804247)

#### 6. 闭包和立即执行函数分别指的是什么？

1. **闭包**: 

    > 回答模式： 1. 什么是[闭包];  2. 【闭包】的作用是什么？

    **闭包是什么**：【函数】和【函数内部能访问到的变量】（环境）的总和，就是一个闭包
    **闭包的作用**：【间接访问一个变量】

2. **立即执行函数**

    > 回答模式： 1. 什么是立即执行函数； 2. 立即执行函数有什么用途

    **立即执行函数**就是【声明一个匿名函数，然后立马调用这个匿名函数】
    eg: `(function() {alert('我是一个匿名函数')})()`

    **立即执行函数的作用**：【创造一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」）】

#### 7. 什么是JSONP? 什么是CORS? 什么是跨域？

> 同源策略：从一个源的文档或者脚本如何与另外一个源的资源进行交互，这是一个隔离潜在恶意文件的关键安全机制（**源：协议、域名、端口，这三者有一个不同，则源不同**）

* JSONP:
    + JSONP是通过script标签加载数据的方式去获取数据当做js代码来执行
    + 提前在页面中声明一个函数，函数名通过接口传参的方式传给后台，后台解析到这个函数名后在原始数据上「包裹」这个函数名，发送给前端。简而言之，JSONP需要跟对应接口的后端配合才能实现。----只能发起get请求
* CORS：在必须跨域访问资源的情况下，浏览器和服务器怎么沟通（一般协议）
     + 跨源资源共享，它允许浏览器向跨源服务器，发送XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。（需要客户端与服务端共同配合设置）----支持所有类型http请求
     + 简单请求: (1. 请求方法是HEAD、GET、POST三种方法的任意一种； 2. HTTP的头信息不能超过：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：application/x-www.from-urlencoded、multipart/form-data、text/plain )
     + 复杂请求：(1. 请求方法是：PUT、DELETE; 2. Content-Type: application/json)
* 跨域：在浏览器同源策略的情况下，向不同的源发送XHR请求，浏览器认为该请求不受信任，禁止请求

#### 8. aysnc/await怎么用，如何捕获异常？

**aysnc/await**

`aysnc`表示函数里有异步操作，返回一个平promise对象，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句

`await`命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值

```js
// async
// 函数声明
async function foo(){}
// 函数表达式
const foo = async function() {}
// 对象的方法
let obj = { async foo() {} };
obj.foo().then(....);
// class方法
class Storage() {
    constructor() {
        super();
        this.cachePromise = caches.open('avators')
    }
    async getArray(name) {
        const cache = await this.cachePromise;
        return cache.match(`/avatars/${name}.jpg`);
    }
}
const storage = new Storage();
storage.getArray('kate').then(...)
// 箭头函数
const foo = async () =>{}
```

捕获异常：async函数内部抛出错误，会导致返回的promise对象变成reject状态。抛出的错误对象会被catch方法回调接收。除了使用.catch来错误异常，还可以使用try/catch来捕获异常

```js
async handleSubmit() {
    await Promise.all([promise1, promise2]).then(r=>{
        console.log(r)
    }).catch(err => {
        console.log(err)
    })
}
async handleSubmi() {
    try{
        await Promise.all([promise1, promise2]);
        return true
    } catch(err) {
        console.log(err)
        return false
    }
}
```

#### 9. 如何实现深拷贝？

> 深拷贝：将一个对象从内存总完整的拷贝出来，从堆内存中开辟一个区域来存放新对象，且修改新对象不会影响原对象

> 背代码，要点：
>
> 1. 递归
> 2. 判断类型
> 3. 检查环（循环引用）
> 4. 需要忽略原型

**1.  基础版本（不包括数组和嵌套）**

```js
function clone(target) {
    let cloneTarget = {};
    for(const key in target) {
        cloneTarget[key] = target[key]
    }
    return cloneTarget
}
```

**2. 升级版本**

> weakMap对象是一组键/值对的集合，其中的键是弱引用。期键必须是对象，而值可以是任意的
>
> **weakMap的作用：**如果要拷贝的对象非常庞大时，使用Map会对内存造成非常大的额外消耗，而且我们需要手动清除Map的属性才能释放这块内存，而weakMap可以帮我们化解这个问题
>
> **强引用**：

```js
function forEachKey(arr, iteratee){
    let index = -1;
    const length = arr.length;
    while(++index < length) {
        iteratee(array[index], index)
    }
    return array
}
function clone(target, map = new weakMap()) {
	// 判断类型
    if(typeof target === 'object') {
        const isArray = Array.isArray(target);
        let cloneTarget = isArray ? [] : {};
        // 防止循环引用
        if(map.get(target)){
            return map.get(target)
        }
        map.set(target, cloneTarget);
        // 克隆对象和数组
        const keys = isArray ? undefined : Object.keys(target);
        forEachKey(keys || target, (value, key) => {
            if(keys) {
                key =value
            }
            cloneTarget[key] = clone(target[key], map)
        })
        return cloneTarget
    } else {
    	return target
    }
}
```

#### 10. 如何正则实现trim()? 去除空格(背代码)

```
String.prototype.trim = function() {
	return this.replace(/^\s+$/g, '')
}
// 方式2
function trim(string) {
	return string.replace(/^\s+$/g, '')
}
```

#### 11. 不使用class如何实现继承？用class又如何实现？（背代码）

```js
// 使用call和原型链
function Person(name, year) {
    this.name = name;
    this.year = year;
}
function Child(color) {
    Person.call(this)
    this.color = color
}
Child.prototype = Object.create(Person.prototype)
Child.prototype.constructor = Child

```

```
// 使用class实现继承
class Person {
	constructor(color) {
		this.color = color
	}
}
class Child extends Person{
	constructor(coloe, name) {
		super(color)
		this.name = name
	}
}
```

#### 12. 数组去重

> 1. 计数排序变形，背代码
> 2. 使用 Set（面试已经禁止这种了，因为太简单）
> 3. 使用 WeakMap

#### 13. 手写一个 Promise

参考 https://juejin.im/post/5aafe3edf265da238f125c0a

### 二、DOM相关

#### 1. DOM事件类：DOM事件级别

> 1. DOM1.0 ：element.onclick = function() {}
> 2. DOM2.0：element.addEventLister('click', function() {}, false)
> 3. DOM3.0：element.addEventLister('keyup', function() {}, false) // 新增键盘事件

#### 2. DOM事件模型：冒泡与捕获

> 捕获：从上而下： 开始为window
>
> 捕获：从目标元素开始往上面找

**DOM事件流**：

#### 1. 事件委托

```

```



### typescript

	1.never类型是什么？ 不应该出现的类型


​	
​	

说明文档

1、描述：本项目高效便捷地实现社区的人、财、物的管理，涵盖社区服务、社商经营、平台运营和企业管理四大模块。流程化管理与个性化运营相结合，可建立物业服务标准、流程标准、管家服务体系等标准化管理流程，也可针对各社区做个性化配置。实时掌握社区用户及社区服务人员动态，快速响应用户的服务请求，智能调度社区服务人员，为社区用户提供高品质的物业服务

主要负责：1. 负责各版本需求迭代，高质量高保真输出UI与需求；

2、描述：

### 三. 构建工具

#### Gulp是web开发中帮助你自动完成任务的工具，基于Nodejs Stream 流的批量处理工具

> Gulp的核心：
>
> 1. 如何制定一套合理、可配置、能够真正提升我们工作效率的构建流程
> 2. 如何在需要某个功能时，能够快速找到最合适的那个插件，且能够快速使用
>
> Gulp的特点：
>
> + 万事皆任务
> + 基于NodeJs数据流

+ 启动Web Server
+ 当文件修改保存后，自动刷新浏览器
+ 批量处理Sass或者Less文件
+ babel转ES11高级版本到Es5
+ 优化资源Css、Javascript、Images

#### 使用方式

1. 全局安装gulp-cli: `npm i -g gulp-cli`

2. 局部安装：`npm i glup --save-dev`

3. 创建默认任务`gulpfile.js`

4. 创建copy任务

   > gulp暴露了src()和dest()方法用于处理计算机上存放的文件
   >
   > + src()进行文件读入： 选择需要的文件，读取内存种并通过流进行处理
   > + dest()进行输出文件：将文件存在系统目录内

5. 

   ```
   // 
   
   ```

### 框架内：Vue、React(核心)

#### Vue

##### 1.1 数据双向绑定原理（数据驱动视图）

>  **UI = render(state)**: 状态state是输入，页面UI是输出，状态输入一旦变了，页面输出也随之而改变，这种特性就是数据驱动试图

+ 变化侦察： 追踪状态 。

  **angular**中是通过脏值检测流程来实现变化侦察；

  **react**中是通过对比虚拟Dom来实现变化侦测

  **vue**中是使用`Object.defineProperty`来检测

  + `Object.defineProperty`检测数据更新（**针对Object的变化侦测**）

    > vue源码中定义了一个Observer类，它将一个正常的object转换为可检测的object,并且给value新增一个__ob__属性，值为value的Observer实例。这个操作相当于为value打上了标记，表示它已经被转化为响应式了，可避免重复操作.

    ```js
    // 源码位置：src/core/observer/index.js
    /**
     * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
     */
     export class Observer {
     	constructor(value) {
     		this.value = value;
     		def(value, '__ob__', this)
     		if(Array.isArray(value)){
     			// 处理value是数组的逻辑
     		} else {
     			this.walk(value)
     		}
     	}
     	walk(obj: Object){
     		const keys = Object.keys(obj)
     		for(let key= 0; key < keys.length, key++) {
     			defineReactive(obj, keys[i])
     		}
     	}
     }
     defineReactive(obj, key, val) {
     	// 如果只传了obj和key,那么val = obj[key]
     	if(arguments.length === 2) {
     		val = obj[key]
     	}
     	if(typeof val === 'object') {
     		new Observer(val)
     	}
     	Object.defineProperty(obj, key, {
     		enumerable: true,
     		configurable: true,
     		get: function() {
     			return val
     		}, 
     		set: function(newVal) {
     			if(val === newVal) {
                     return
     			}
     			val = newVal
     		}
     	})
     }
    ```

  + 依赖收集：使用者使用了这个数据（即依赖了这个数据），每个数据都有一个依赖数组，谁依赖了这个数据，我们就把这个数据放到这个依赖数组中，当数据发生变化时，就去它对应的依赖数组依次通知。**在getter中收集依赖，在setter中通知依赖更新**

  + 依赖收集到了哪里？ 给每个数据建立一个**依赖管理器**，然后把这个数据的所有依赖都管理起来

    ```js
    // 源码位置：src/core/observe/dep.js
    exports default class Dep{
    	constructor() {
            this.subs = [] // 存放依赖
        }
        // 新增
        addSub(sub) {
    		this.subs.push(sub)
        }
    	// 删除一个依赖
    	removeSub(sub) {
            remove(this.subs, sub)
        }
    	// 添加一个依赖
    	depend(sub) {
            if(window.target) {
                this.addSub(window.target)
            }
        }
    	// 通知所有依赖
    	notify() {
            const subs = this.subs.slice()
            for(let i=0; l=subs.length, i< l, i++) {
                subs[i].update()
            }
        }
    }
    // 删除单个项
    export function remove(arr, item) {
        if(arr.length) {
            const index = arr.indexOf(item)
            if(index > -1) {
                return arr.splice(index, 1)
            }
        }
    }
    ```

    有了依赖器之后，可在getter中收集依赖，setter中通知依赖更新

    ```js
    function defineReative(obj, key, val) {
        if(arguments.length === 2) {
            val = obj[key]
        }
        if(typeof obj === 'object') {
            new Observer(val)
        }
        const dep = new Dep();
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function() {
                dep.depend(val)
                return val
            },
            set: function(newVal) {
                if(val === newVal) {
                    return
                }
                val = newVal
                dep.notify()
            }
        })
    }
    ```

    + 实际依赖：谁使用了数据，谁就是依赖，我们就为之创建一个`watcher`实例。在创建`watcher`实例的过程中自动会把自己添加到数据对应的依赖管理器中，以后这个`watcher`实例就代表这个依赖，当数据变化时，我们就通知这个`watcher`实例，由`watcher`实例再去通知真正的依赖

    + **总结**：`watcher`先把自己设置到全局唯一指定位置（window.target）,然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着，在`getter`中就会从全局唯一的那个位置读取正在读取数据的`watcher`，并把这个`watcher`收集到`Dep`中。收集好之后，当数据发生变化时，会向`Dep`中每个`watcher`发送通知。通过这样的方式，`watcher`可以主动去订阅任意一个数据的变化。如图所示

      ![img](https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg)

    + **以上方式的缺点：**Object.defineProperty虽然实现了对对象数据的取值和设置值，但是在向object中添加key/value键值对或者删除一对已有的key/value键值对时，它是无法检测到的。针对这一问题Vue提供了`vue.set`和`vue.delete`方法通知视图更新

  + **总结流程**

    1. `Data`通过`Observer`转换成了`getter\setter`的形式来追踪变化
    2. 当外界通过`watcher`读取数据时，会触发`getter` 从而将`watcher`添加到依赖。
    3. 当数据方式变化时，会触发`setter`,从而向`Dep`中依赖（即`Watcher`）发送通知。
    4. `Watcher`接收到通知后，会向外界发送通知，变化通知到外界可能会触发视图更新，也可能出发用户的某个回调函数等等

  + **Array的变化检测**：在获取数据时收集依赖，数据变化时依赖更新

    + 数组无法使用`Object.defineProperty`方法，但是在Vue中我们定义数组时其实也是放在一个`object`对象中，只要在这个`object`数据对象中获取这个数组的数组就会触发`getter`,即可在`getter`中收集依赖

    + Vue中创建了一个数组方法拦截器，它拦截在数组实例与`Array.property`之间，在拦截器内重写了操作数据的一些方法，当数组实例使用操作数组方法时，其实使用的就是拦截器重写的方法，而不在使用`Array.prototype`上的原生方法

      ![img](https://vue-js.com/learn-vue/assets/img/2.b446ab83.png)

      `Array`原型中可以改变数组自身内容的方法有7个：`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`

      ```js
      // 源码地址：src/core/observer/array.js
      const arrayProto = Array.prototype;
      // 创建一个拦截器
      export const arrayMethods = Object.create(arrayProto)
      // 改变数组自身内容的7个方法
      const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
      methodsToPatch.forEach(method => {
          const original = arrayProto[method] // 缓存原生方法
          Object.defineProperty(arrayMethods, method, {
              enmuerable: false,
              configurable: true,
              widthable,
              value: function mutator(...args) {
                  const result = original.apply(this, args)
                  return result
              }
          })
      })
      
      ```

      

  

##### 1.2 Virtual DOM 原理以及diff算法

> + Virtual DOM: 虚拟DOM，用一个`js`对象来描述一个`DOM`节点
>
> + 为什么需要虚拟DOM： vue是数据驱动视图，数据发生变化视图就要随之发生变化，在更新视图的时候难免会操作DOM，而操作真实Dom是非常耗费性能，一个真正的DOM是非常庞大的
> + 产生的原因和最大的用途：使用js模拟出的一个dom节点，称之为虚拟dom节点。当数据发生变化时，我们对比变化前后的虚拟dom节点，通过`DOM-diff`算法计算出需要更新的地方，然后再去更新需要更新的视图

+ **Vnode类**

  ```js
  // /源码地址： src/core/vdom/vnode.js
  export default class VNode {
    constructor (
      tag?: string,
      data?: VNodeData,
      children?: ?Array<VNode>,
      text?: string,
      elm?: Node,
      context?: Component,
      componentOptions?: VNodeComponentOptions,
      asyncFactory?: Function
    ) {
      this.tag = tag                                /*当前节点的标签名*/
      this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
      this.children = children  /*当前节点的子节点，是一个数组*/
      this.text = text     /*当前节点的文本*/
      this.elm = elm       /*当前虚拟节点对应的真实dom节点*/
      this.ns = undefined            /*当前节点的名字空间*/
      this.context = context          /*当前组件节点对应的Vue实例*/
      this.fnContext = undefined       /*函数式组件对应的Vue实例*/
      this.fnOptions = undefined
      this.fnScopeId = undefined
      this.key = data && data.key           /*节点的key属性，被当作节点的标志，用以优化*/
      this.componentOptions = componentOptions   /*组件的option选项*/
      this.componentInstance = undefined       /*当前节点对应的组件的实例*/
      this.parent = undefined           /*当前节点的父节点*/
      this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
      this.isStatic = false         /*静态节点标志*/
      this.isRootInsert = true      /*是否作为跟节点插入*/
      this.isComment = false             /*是否为注释节点*/
      this.isCloned = false           /*是否为克隆节点*/
      this.isOnce = false                /*是否有v-once指令*/
      this.asyncFactory = asyncFactory
      this.asyncMeta = undefined
      this.isAsyncPlaceholder = false
    }
  
    get child (): Component | void {
      return this.componentInstance
    }
  }
  ```

  上面的代码可以看出：`Vnode`类中包含了描述一个真实`DOM`节点所需要的一系列属性，如`tag`表示节点标签名，`text`表示节点包含的文本，`children`表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实`DOM`节点

+ **Vnode类型：** 注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点

  1. **注释节点**：只需要两个属性

     ```js
     // 创建注释节点
     export const createEmptyVNnode = (text: string) {
     	const node = new VNode()
     	node.text = text; // 具体的注释信息
     	node.isComment = true; // 标识一个节点是否是注释节点
     	return node
     }
     ```

  2. **文本节点**：描述比注释节点更简单，只需要一个属性，`text`属性：用来表示具体的文本信息

     ```js
     // 创建文本节点
     export function createTextVNode(val: string | number) {
         return new VNode(underfind, underfind, underfind, String(val))
     }
     ```

  3. **克隆节点**：把一个已经存在的几点复制一份出来，它主要是为了做模板编译优化时使用, 现有节点与新克隆等到的几点唯一的区别时`isCloned`为`true`

     ```js
     // 创建克隆节点
     export function cloneVNode (vnode: VNode): VNode {
       const cloned = new VNode(
         vnode.tag,
         vnode.data,
         vnode.children,
         vnode.text,
         vnode.elm,
         vnode.context,
         vnode.componentOptions,
         vnode.asyncFactory
       )
       cloned.ns = vnode.ns
       cloned.isStatic = vnode.isStatic
       cloned.key = vnode.key
       cloned.isComment = vnode.isComment
       cloned.fnContext = vnode.fnContext
       cloned.fnOptions = vnode.fnOptions
       cloned.fnScopeId = vnode.fnScopeId
       cloned.asyncMeta = vnode.asyncMeta
       cloned.isCloned = true
       return cloned
     }
     ```

  4. 元素节点：这种类型的节点更贴近我们通常看到的真实`DOM`节点，它具有描述节点标签名词的`tag`属性，描述节点属性如：`class`、`attrbutes`等的`data`属性，有描述包含的子节点信息的	`children`属性等。由于元素节点包含的情况比较复杂，所以源码中没有直接写死

     ```js
     // 真实DOM节点
     <div id='a'><span>难凉热血</span></div>
     
     // VNode节点
     {
       tag:'div',
       data:{},
       children:[
         {
           tag:'span',
           text:'难凉热血'
         }
       ]
     }
     ```

  5. **组件节点：**组件节点 出了有元素节点具有的属性之外，它还有两个特有的属性：

     + componentOptions: 组件的option选项，如组件的`props`等
     + componentInstance：当前组件节点对应的`Vue`实例

  6. **函数式组件节点**：函数式组件节点相较于组件节点，它又有两个特有的属性：】

     + fnContext：函数式组件对应的Vue实例
     + fnOptions：组件的option选项

+ **VNode总结**

  以js的计算性能来换取操作真实`DOM`所消耗的性能。在Vue中是通过VNode类来实例化出不同类型的虚拟dom节点，并且学习了不同类型节点生产的属性不同，所谓不同类型的节点其本质还是一样的呃，都是Vnode类的实例，只是在实例化时传入的属性参数不同罢了。VNode的作用，有了数据变化前后的VNode,我们才能进行后续的`DOM-diff`找出 差异，最后做到只更新有差异的视图，从而达到尽可能少的操作真实`DOM`的目的，以节省性能。
  
+ ##### **DOM-diff算法**

  > DOM-diff过程： VNode的最大用途就是在数据变化前后生成真实DOM对应的虚拟DOM节点,然后对比新旧两份VNode，找出差异所在，然后更新有差异的`DOM`节点，最终达到以最少操作真实`DOM`更新视图的目的。而对比新旧两份VNode并找出差异的过程就是`DOM-diff`过程

  1. patch：其实就是DOM-diff过程，即对旧的VNode修补，打补丁从而得到新得VNode(**对比新旧两份`VNode`的过程，以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch要干的事情**) ，其实只干了三件事情：

     1. 创建节点：新的`VNode`中有而旧的`vnode`中没有，就在旧的`VNode`中创建；

        > Vnode可以描述6种类型的节点，实际中只有三种类型(**元素节点、文本节点、注释节点**)的节点可以被创建并插入到`DOM`，vue在创建节点的时候就会判断在新的`vnode`中有而	旧的`vnode`中没有的节点属于那种类型的节点，从而调用不同的方法创建并插入到DOM中

        ```js
        // 源码位置: /src/core/vdom/patch.js
        function createElm (vnode, parentElm, refElm) {
            const data = vnode.data
            const children = vnode.children
            const tag = vnode.tag
            if (isDef(tag)) {
              	vnode.elm = nodeOps.createElement(tag, vnode)   // 创建元素节点
                createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点
                insert(parentElm, vnode.elm, refElm)       // 插入到DOM中
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps.createComment(vnode.text)  // 创建注释节点
              insert(parentElm, vnode.elm, refElm)           // 插入到DOM中
            } else {
              vnode.elm = nodeOps.createTextNode(vnode.text)  // 创建文本节点
              insert(parentElm, vnode.elm, refElm)           // 插入到DOM中
            }
          }
        ```

        + 判断是否为元素节点只需要判断`VNode`节点是否有`tag`标签即可，若有则认为是元素节点，则调用`createElement`方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后`insert`插入到当前元素节点里面，最后把当前元素节点插入到`DOM`中

        + 判断是否为注释节点，只需判断`VNode`的`isComment`属性是否为`true`。若为`true`则为注释节点，就调用`createComment`方法创建注释节点，再插入到`DOM`中。

        + 如果既不是元素节点又不是注释节点，那就认为是文本节点，则调用`createTextNode`方法创建文本节点，再插入到`DOM`中

          > 代码中的`nodeOps`是`vue`为了跨平台兼容性，对所有节点操作进行了封装，例如：`nodeOps.createTextNode()`在浏览器端等同于`document.createTextNode()`

          ![img](https://vue-js.com/learn-vue/assets/img/2.02d5c7b1.png)

     2. 删除节点：新的`VNode`中没有而旧的`vnode`中有，就在旧的`VNode`中删除；

        > 如果某些节点再新的`VNode`中没有而在旧的`oldVNode`中有，那么就需要把这些节点从旧的`oldVNode`中删除。删除节点非常简单，只需在要删除节点的父元素上调用`removeChild`方法即可

        ```js
        function removeNode (el) {
            const parent = nodeOps.parentNode(el)  // 获取父节点
            if (isDef(parent)) {
              nodeOps.removeChild(parent, el)  // 调用父节点的removeChild方法
            }
          }
        ```

        

     3. 更新节点：新的`VNode`和旧的`vnode`中都有，就以新的`VNode`为准，更新旧的`VNode`

        > 当某些节点在新的`VNode`和旧的`oldVNode`中都有时，我们就需要细致比较一下，找出不一样的地方进行更新
        >
        > **静态节点**：该节点只包含了纯文字，没有任何可变的变量，不论数据如何变化，只要这个节点第一次渲染了，那么它以后都不会在发生变化了，数据发生任何变化都与他无关

        ```js
        // 更新节点
        function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
          // vnode与oldVnode是否完全一样？若是，退出程序
          if (oldVnode === vnode) {
            return
          }
          const elm = vnode.elm = oldVnode.elm
        
          // vnode与oldVnode是否都是静态节点？若是，退出程序
          if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
          ) {
            return
          }
        
          const oldCh = oldVnode.children
          const ch = vnode.children
          // vnode有text属性？若没有：
          if (isUndef(vnode.text)) {
            // vnode的子节点与oldVnode的子节点是否都存在？
            if (isDef(oldCh) && isDef(ch)) {
              // 若都存在，判断子节点是否相同，不同则更新子节点
              if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
            }
            // 若只有vnode的子节点存在
            else if (isDef(ch)) {
              /**
               * 判断oldVnode是否有文本？
               * 若没有，则把vnode的子节点添加到真实DOM中
               * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中
               */
              if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
            }
            // 若只有oldnode的子节点存在
            else if (isDef(oldCh)) {
              // 清空DOM中的子节点
              removeVnodes(elm, oldCh, 0, oldCh.length - 1)
            }
            // 若vnode和oldnode都没有子节点，但是oldnode中有文本
            else if (isDef(oldVnode.text)) {
              // 清空oldnode文本
              nodeOps.setTextContent(elm, '')
            }
            // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么
          }
          // 若有，vnode的text属性与oldVnode的text属性是否相同？
          else if (oldVnode.text !== vnode.text) {
            // 若不相同：则用vnode的text替换真实DOM的文本
            nodeOps.setTextContent(elm, vnode.text)
          }
        }
        ```

        ​	![img](https://vue-js.com/learn-vue/assets/img/3.7b0442aa.png)

     1. 如果`VNode`和`oldVNode`均为静态节点， 直接ruturn

     2.  如果`VNode`是文本节点:

        a. 如果`oldVNode`也是文本节点，比较两者文本不相同，则把`oldVNode`里的文本改成跟`VNode`的文本一样;

        b. 如果`oldVNode`不是文本节点，那么不论它是什么，直接调用`setTextNode`方法把它改成文本节点，并且文本内容跟`VNode`相同

     3. 如果`VNode`是元素节点：

        + 该节点包含子节点（🔶🔶🔶🔶）

          如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。

        + 该节点不包含子节点

          如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。

     4. `VNode`是元素节点包含了子节点（**更新子节点**）

        当新的`VNode`与旧的`VNode`都是元素节点且都包含子节点时，那么这两个节点的`VNode`实例上的children属性是包含的子节点数组，新`VNode`的子节点为`newchildren`, 旧`VNode`的子节点为`oldChildren`，外层循环`newchildren`内层循环`oldChildren`，这个过程会出现四种情况：

        + **创建子节点**：如果`newchildren`里面的某个子节点在`oldChildren`里面找不到相同的子节点，那么说明这个节点是之前没有的，所有需要新增这个节点，即创建节点；（**合适的位置是所有未处理节点之前，而并非所有已处理节点之后**）

        + **删除子节点**：如果`newchildren`循环完毕后，`oldChildren`里面还有未处理的子节点，那说明这些节点是要被废弃的，处理删除即可

        + **移动子节点：**如果`newchildren`里面的某个子节点在`oldChildren`里面找到了相同节点，但是所处位置不同，那么需要以`newchildren`里面的子节点为基准，调整`oldChildren`里该节点的位置，使之与在`newchildren`的位置相同

        + **更新子节点：**如果`newchildren`里面的某个子节点在`oldChildren`里面找到了相同节点，且所处位置也是相同，那么直接在`oldChildren`中更新该节点，使之与`newChildren`里的该节点相同

          ```js
          // 源码位置： /src/core/vdom/patch.js
          if (isUndef(idxInOld)) {    // 如果在oldChildren里找不到当前循环的newChildren里的子节点
              // 新增节点并插入到合适位置
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          } else {
              // 如果在oldChildren里找到了当前循环的newChildren里的子节点
              vnodeToMove = oldCh[idxInOld]
              // 如果两个节点相同
              if (sameVnode(vnodeToMove, newStartVnode)) {
                  // 调用patchVnode更新节点
                  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
                  oldCh[idxInOld] = undefined
                  // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动
                  canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
              }
          }
          ```

          ```js
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          // 等同于
          if(canMove){
              nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          }
          ```

     5. **优化更新子节点**（🔶🔶🔶🔶🔶🔶🔶🔶）

        > 内外侧循环可解决一部分问题，但是存在当包含子节点数量很多时。这样循环算法的事件复杂度就会变的很大，不利于性能提升，vue对此进行了优化升级

        1. 优化策略

           按照旧方法会存在算法时间复杂度就会非常高，不利于性能提升

           优化策略可以不用按照顺序去循环`newChildren`和`oldChildren`这两个数组，可以先比较这两个数组里特殊位置的子节点（**从两边向中间找**）

           ![img](https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png)

           + `newChildren`数组里的所有未处理子节点的第一个子节点称为：**新前**；
           + `newChildren`数组里的所有未处理子节点的最后一个子节点称为：**新后**；
           + `oldChildren`数组里的所有未处理子节点的第一个子节点称为：**旧前**；
           + `oldChildren`数组里的所有未处理子节点的最后一个子节点称为：**旧后**；

           1. ## 新前与旧前

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/9.e017b452.png)

           2. ## 新后与旧后

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。

              ![img](https://vue-js.com/learn-vue/assets/img/10.cf98adc0.png)

           3. ## 新后与旧前

              把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/11.2ddb5ee5.png)

              此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，**更新节点要以新`VNode`为基准，然后操作旧的`oldVNode`，使之最后旧的`oldVNode`与新的`VNode`相同**。那么现在的情况是：`newChildren`数组里的最后一个子节点与`oldChildren`数组里的第一个子节点相同，那么我们就应该在`oldChildren`数组里把第一个子节点移动到最后一个子节点的位置，如下图：

              ![img](https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png)

              从图中不难看出，我们要把`oldChildren`数组里把第一个子节点移动到数组中**所有未处理节点之后**。

              如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。

           4. ## 新前与旧后

              把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；

              ![img](https://vue-js.com/learn-vue/assets/img/13.98dbc208.png)

              同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是`newChildren`数组里的第一个子节点与`oldChildren`数组里的最后一个子节点相同，那么我们就应该在`oldChildren`数组里把最后一个子节点移动到第一个子节点的位置，如下图：

              ![img](https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png)

              从图中不难看出，我们要把`oldChildren`数组里把最后一个子节点移动到数组中**所有未处理节点之前**。

              OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。

           5. ## 源码

              ```js
              // 循环更新子节点
                function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                  let oldStartIdx = 0               // oldChildren开始索引
                  let oldEndIdx = oldCh.length - 1   // oldChildren结束索引
                  let oldStartVnode = oldCh[0]        // oldChildren中所有未处理节点中的第一个
                  let oldEndVnode = oldCh[oldEndIdx]   // oldChildren中所有未处理节点中的最后一个
              
                  let newStartIdx = 0               // newChildren开始索引
                  let newEndIdx = newCh.length - 1   // newChildren结束索引
                  let newStartVnode = newCh[0]        // newChildren中所有未处理节点中的第一个
                  let newEndVnode = newCh[newEndIdx]  // newChildren中所有未处理节点中的最后一个
              
                  let oldKeyToIdx, idxInOld, vnodeToMove, refElm
              
                  // removeOnly is a special flag used only by <transition-group>
                  // to ensure removed elements stay in correct relative positions
                  // during leaving transitions
                  const canMove = !removeOnly
              
                  if (process.env.NODE_ENV !== 'production') {
                    checkDuplicateKeys(newCh)
                  }
              
                  // 以"新前"、"新后"、"旧前"、"旧后"的方式开始比对节点
                  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                    if (isUndef(oldStartVnode)) {
                      oldStartVnode = oldCh[++oldStartIdx] // 如果oldStartVnode不存在，则直接跳过，比对下一个
                    } else if (isUndef(oldEndVnode)) {
                      oldEndVnode = oldCh[--oldEndIdx]
                    } else if (sameVnode(oldStartVnode, newStartVnode)) {
                      // 如果新前与旧前节点相同，就把两个节点进行patch更新
                      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
                      oldStartVnode = oldCh[++oldStartIdx]
                      newStartVnode = newCh[++newStartIdx]
                    } else if (sameVnode(oldEndVnode, newEndVnode)) {
                      // 如果新后与旧后节点相同，就把两个节点进行patch更新
                      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
                      oldEndVnode = oldCh[--oldEndIdx]
                      newEndVnode = newCh[--newEndIdx]
                    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                      // 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后
                      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
                      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
                      oldStartVnode = oldCh[++oldStartIdx]
                      newEndVnode = newCh[--newEndIdx]
                    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                      // 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前
                      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
                      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
                      oldEndVnode = oldCh[--oldEndIdx]
                      newStartVnode = newCh[++newStartIdx]
                    } else {
                      // 如果不属于以上四种情况，就进行常规的循环比对patch
                      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
                      idxInOld = isDef(newStartVnode.key)
                        ? oldKeyToIdx[newStartVnode.key]
                        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
                      // 如果在oldChildren里找不到当前循环的newChildren里的子节点
                      if (isUndef(idxInOld)) { // New element
                        // 新增节点并插入到合适位置
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                      } else {
                        // 如果在oldChildren里找到了当前循环的newChildren里的子节点
                        vnodeToMove = oldCh[idxInOld]
                        // 如果两个节点相同
                        if (sameVnode(vnodeToMove, newStartVnode)) {
                          // 调用patchVnode更新节点
                          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
                          oldCh[idxInOld] = undefined
                          // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动
                          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
                        } else {
                          // same key but different element. treat as new element
                          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
                        }
                      }
                      newStartVnode = newCh[++newStartIdx]
                    }
                  }
                  if (oldStartIdx > oldEndIdx) {
                    /**
                     * 如果oldChildren比newChildren先循环完毕，
                     * 那么newChildren里面剩余的节点都是需要新增的节点，
                     * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中
                     */
                    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
                    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
                  } else if (newStartIdx > newEndIdx) {
                    /**
                     * 如果newChildren比oldChildren先循环完毕，
                     * 那么oldChildren里面剩余的节点都是需要删除的节点，
                     * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除
                     */
                    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
                  }
                }
              ```

              优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环

              ![img](https://vue-js.com/learn-vue/assets/img/15.e9bdf5c1.png)

              + **newStartIdx:**`newChildren`数组里开始位置的下标；
              + **newEndIdx:**`newChildren`数组里结束位置的下标；
              + **oldStartIdx:**`oldChildren`数组里开始位置的下标；
              + **oldEndIdx:**`oldChildren`数组里结束位置的下标；

              **优化策略是新旧节点两两更新，一次更新将会移动两个节点：`newStartIdx`和`oldStartIdx`只能往后移动（只会加），`newEndIdx`和`oldEndIdx`只能往前移动（只会减）**

              当开始位置大于结束位置时，表示所有节点都已经遍历过了

              1. 如果`oldStartVnode`不存在，则直接跳过，将`oldStartIdx`加1，比对下一个

                 ```js
                 // 以"新前"、"新后"、"旧前"、"旧后"的方式开始比对节点
                 while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                 	if (isUndef(oldStartVnode)) {
                         oldStartVnode = oldCh[++oldStartIdx]
                       }
                 }
                 ```

              2. 如果`oldEndVnode`不存在，则直接跳过，将`oldEndIdx`减1，比对前一个

                 ```js
                 else if (isUndef(oldEndVnode)) {
                     oldEndVnode = oldCh[--oldEndIdx]
                 }
                 ```

              3. 如果新前与旧前节点相同，就把两个节点进行`patch`更新，同时`oldStartIdx`和`newStartIdx`都加1，后移一个位置

                 ```js
                 else if (sameVnode(oldStartVnode, newStartVnode)) {
                     patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
                     oldStartVnode = oldCh[++oldStartIdx]
                     newStartVnode = newCh[++newStartIdx]
                 }
                 ```

              4. 如果新后与旧后节点相同，就把两个节点进行`patch`更新，同时`oldEndIdx`和`newEndIdx`都减1，前移一个位置

                 ```js
                 else if (sameVnode(oldEndVnode, newEndVnode)) {
                     patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
                     oldEndVnode = oldCh[--oldEndIdx]
                     newEndVnode = newCh[--newEndIdx]
                 }
                 ```

              5. 如果新后与旧前节点相同，先把两个节点进行`patch`更新，然后把旧前节点移动到`oldChilren`中所有未处理节点之后，最后把`oldStartIdx`加1，后移一个位置，`newEndIdx`减1，前移一个位置

                 ```js
                 else if (sameVnode(oldStartVnode, newEndVnode)) {
                     patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
                     canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
                     oldStartVnode = oldCh[++oldStartIdx]
                     newEndVnode = newCh[--newEndIdx]
                 }
                 ```

              6. 如果新前与旧后节点相同，先把两个节点进行`patch`更新，然后把旧后节点移动到`oldChilren`中所有未处理节点之前，最后把`newStartIdx`加1，后移一个位置，`oldEndIdx`减1，前移一个位置

                 ```js
                 else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                     patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
                     canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
                     oldEndVnode = oldCh[--oldEndIdx]
                     newStartVnode = newCh[++newStartIdx]
                 }
                 ```

              7. 如果不属于以上四种情况，就进行常规的循环比对`patch`

              8. 如果在循环中，`oldStartIdx`大于`oldEndIdx`了，那就表示`oldChildren`比`newChildren`先循环完毕，那么`newChildren`里面剩余的节点都是需要新增的节点，把`[newStartIdx, newEndIdx]`之间的所有节点都插入到`DOM`中

                 ```js
                 if (oldStartIdx > oldEndIdx) {
                     refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
                     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
                 }
                 ```

              9. 如果在循环中，`newStartIdx`大于`newEndIdx`了，那就表示`newChildren`比`oldChildren`先循环完毕，那么`oldChildren`里面剩余的节点都是需要删除的节点，把`[oldStartIdx, oldEndIdx]`之间的所有节点都删除

                 ```js
                 else if (newStartIdx > newEndIdx) {
                     removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
                 }
                 ```

                 

              10. 总结：Vue为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前和旧后，新后和旧后，新后和旧前，新前和旧后。

  ##### 1.3 模板编译

  > 把用户在`<template></template>`标签中写的类似于原生`html`的内容进行编译，把原生`html`的内容找出来，再把非原生`html`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数的这一段过程称为模板编译过程

  ###### 1.3.1 整体渲染流程

  所谓渲染流程，就是吧用户写的类似于原生`html`的模板经过一系列处理最终反应到视图称之为整个渲染流程

  ![img](https://vue-js.com/learn-vue/assets/img/1.f0570125.png)

  ###### 1.3.2 模板编译内部流程

  1. 抽象语法书AST

     > 抽象语法树：在计算机科学中，**抽象语法树**（**A**bstract**S**yntax**T**ree，AST），或简称**语法树**（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是抽象的，是因为这里的语法并不会表示出真实语法中出现的每个细节

  ![img](https://vue-js.com/learn-vue/assets/img/2.5596631a.png)

  2. 具体流程

     将一堆字符串模板解析成抽象语法树`AST`后，可对其进行各种操作处理，处理完后用处理后的`AST`来生成`render`函数。具体流程分为三大阶段：

     1. 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树`AST`；
     2. 优化阶段：遍历`AST`，找到其中的静态节点，并打上标记；
     3. 代码生成阶段：将`AST`转换成渲染函数

     这三个阶段在源码中分别对应三个模块，对应源码路径为：

     1. 模板解析阶段——解析器——源码路径：`src/compiler/parser/index.js`;

     2. 优化阶段——优化器——源码路径：`src/compiler/optimizer.js`;

     3. 代码生成阶段——代码生成器——源码路径：`src/compiler/codegen/index.js`;

        ```js
        // 源码位置: /src/complier/index.js
        export const createCompiler = createCompilerCreator(function baseCompile (
          template: string,
          options: CompilerOptions
        ): CompiledResult {
          // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST
          const ast = parse(template.trim(), options)
          if (options.optimize !== false) {
            // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；
            optimize(ast, options)
          }
          // 代码生成阶段：将AST转换成渲染函数；
          const code = generate(ast, options)
          return {
            ast,
            render: code.render,
            staticRenderFns: code.staticRenderFns
          }
        })
        ```

        可以看到`baseCompole`代码非常的简短主要核心代码

        + **const ast =parse(template.trim(), options)** ：`parse`会用正则等方式解析  `template`模板中的指令、`class`、`style`等数据，形成`AST`;
        + **optimize(ast, options)**：`optimize`的主要作用是标记静态节点，这是在编译过程中的一处优化，挡在进行`patch`的过程中，`DOM-Diff`算法会直接跳过静态节点，从而减少了比较过程，优化了`patch`的性能；
        + **const code =generate(ast, options)**：将 `AST` 转化成 `render`函数字符串的过程，得到结果是 `render`函数 的字符串以及 `staticRenderFns` 字符串；

        最终`baseCompile`的返回值：

        ```js
        {
         	ast: ast,
         	render: code.render,
         	staticRenderFns: code.staticRenderFns
         }
        ```

        最终返回了抽象语法树`AST`

  

+ nextTick实现原理

+ keep-alive实现原理

https://vue-js.com/learn-vue/reactive/object.html#_6-%E6%80%BB%E7%BB%93

